<root>
<source>
/tmp/tmpo9l8mwkb/README_FIRST.md
</source>
<contents>
---
title: Welcome to Lobster!
---

<img src="./lobster.svg" height=250>

Lobster is a statically typed programming language with a Python-esque
syntax that combines the advantages of an expressive type system and
compile-time memory management with a very lightweight, friendly and
terse syntax, by doing most of the heavy lifting for you.

The homepage has more on [the "why" of Lobster](http://strlen.com/lobster/).

Chat on [Discord](https://discord.gg/szJPYdX) or [Gitter](https://gitter.im/lobster_programming_language/community).

This document is the starting point for all the Lobster documentation.

Using the compiler
------------------

A quick [getting started](getting_started.html) guide.

More detailed: using Lobster from the [command line](command_line_usage.html), or setting up
editors such as [VSCode](vscode_ide.html), [Sublime Text](sublime_ide.html),
[Notepad++](notepadpp_ide.html) or [vim](https://github.com/jcorbin/vim-lobster) as IDE.
[Lite-XL](https://github.com/lite-xl/lite-xl/) has a syntax highlighting
[plugin](https://github.com/lite-xl/lite-xl-plugins/blob/master/plugins/language_lobster.lua).

> Right now VSCode is the only one with a lsp.

Learning the language
---------------------

If you already know how to program in at least one C-style language
(C/C++/C\#/Java/JavaScript etc), then a way to get a quick idea of where
Lobster is different is by looking at the [C-style language Cheat
Sheet](C_style%20language%20Cheat%20Sheet%20for%20Lobster.html).

Useful for reference: [all builtin functions](builtin_functions_reference.html)
(this part of the documentation is auto-generated by the compiler).

Tutorials: How to [build a 2D shooter](shooter_tutorial.html) step by step in
Lobster.

To learn the language more in-depth: The [language
reference](language_reference.html). Check out the [style
guide](style_guide.html) before you write lots of code :) Read about the [type
system](type_checker.html) or [memory management](memory_management.html).

Building Lobster
----------------

Read about the [implementation](implementation.html) to be able to compile,
extend or use Lobster for your own C++ projects.

Using the engine
----------------

Lobster comes with [built-in functionality for drawing](engine.html)
and many other things.

About Lobster
-------------

Lobster was designed and implemented by Wouter van Oortmerssen (aardappel at
gmail dot com / strlen.com).

It has been released under the Apache v2 open source licence.

Read about the [design philosophy, history and future](philosophy.html).
</contents>
<source>
/tmp/tmpo9l8mwkb/command_line_usage.md
</source>
<contents>
---
title: Using Lobster from the command line
---

Basic usage
-----------

If you have a file `helloworld.lobster` that contains

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print "Hello, World!"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

then running it like so will compile and run it:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bin/lobster helloworld.lobster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Command line options
--------------------

Format: `lobster [ OPTIONS ] [ FILE ] [ -- ARGS ]`

-   `FILE` : main Lobster file to compile & run.

-   `-- ARGS` pass args to the running Lobster program, available from
    `command_line_arguments()`. Must be last on the command-line.

-   `--pak` or `--rpak` : generates a pakfile (currently always called "`default.lpak`") in the
    same folder as the `.lobster` file it reads, and doesn't run the program
    afterwards. If you run lobster with no arguments at all, it will try to load
    "`default.lpak`" from the same folder it resides in. Only `--rpak` includes
    runnable code in the pak, useful with jit mode runs, whereas without is useful with
    executables build with `--cpp`.
    Distributing programs created in lobster can be as simple as packaging up the lobster
    executable with a runnable pakfile. The pakfile contains the libtcc C code, and any data
    files you have specified with the `pakfile` keyword, see “Distributing
    Lobster programs” in the [implementation](implementation.html) documentation.

-   `--cpp` : compiles to a .cpp file. Please make sure to follow
    [implementation](implementation.html) on how to use this feature.
    Useful if you’ve created something in Lobster that could use a bit more speed,
    for a shipping build. Not recommend to be used during development.

-   `--import RELDIR` specifies a dir relative to FILE from which `import`
    (and `pakfile`) statements can be resolved, or any loading the running
    program does. Does the same as adding `import from "RELDIR"` to the top
    of your program.

-   `--runtime-no-asserts` : Compile with asserts off, don't use unless you know what you're doing.
-   `--runtime-asserts` : Compile with asserts on (default).
-   `--runtime-stack-traces` : Compile with asserts on + line info + function tracking
    for better runtime errors (stack traces) and profiling. Small effect on speed.
-   `--runtime-debug` : Same as verbose, but now tones inlining way down to get
    better stack traces. Larger effect on speed.
-   `--runtime-debug-dump`: In addition, creates a memory dump file on error.
-   `--runtime-debugger`: Automatically breaks into the
    graphical debugger on errors.

-   `--main MAIN` : after compiling FILE, if present, compile this file and
    run it. This is useful when running Lobster from an editor, where you
    may be editing a module that is not the main file, would like to see that it
    compiles by itself, but to run it need to be launching the main Lobster
    program it belongs to (e.g. `main.lobster` in the same folder).

-   `--wait` : makes the compiler wait for commandline input before it exits. Useful
    in Windows batch files.
-   `--noconsole` : Close console window (Windows)

-   `--verbose` : verbose mode, outputs additional stats about the program being
    compiled/run. `--debug` outputs even more, only useful for working on the compiler.
-   `--silent` : Only output errors.

-   `--full-error` : Lobster is able to generate _compile time stack traces_ when
    the typechecker fails, but those can get long, so by default they get truncated.
    Use this option to not truncate them, and also dump additional information on
    free/local variables in the function context.

-   `--gen-builtins-html` : dumps a help file of all builtin functions the
    compiler knows about to `builtin_functions_reference.html`.
    `--gen-builtins-names` dumps a plain text list of functions, useful for
    adding to syntax highlighting files etc.

-   `--parsedump` : dumps internal representations of the program as AST.
    Only useful for compiler development or if you are really curious.

-   `--non-interactive-test` : Quit after running 1 frame. Useful for running graphical
    programs as part of a test suite.

-   `--query`: Ask the compiler to answer a query about definitions in the program being
    compiled. When is this mode, the compiler does not try to do a full compilation,
    but simply tries to answer the query, including ignoring errors or aborting half-way
    if it has to.
    This option is for use by an IDE or LSP server implementation.
    All further args are passed to the query.
    The first arg is the kind of query (e.g. `definition` or `complete`).
    The second arg is the file this query should take place in (as a relative path, i.e
    `foo/bar.lobster`).
    The 3rd arg is the line where the query should happen.
    The 4th arg is the identifier the query is about.
    The rest of the args depend on the query type, if any.
    For `definition` a response will be the location of the definition.
    For `complete`, it will return a list of possible fields/methods.

Lobster source code may start with a shebang `#!` so you can embed the command-line in
a Lobster script.

Default directories
-------------------

It's useful to understand the directories lobster uses, both for reading source
code files and any data files the program may use:

-   the root repo directory: This is the main folder that has the default
    `bin modules data docs samples tests` folders inside of it.

-   the auxiliary directory: this is where the main `.lobster` file being
    compiled resides.

-   the directory for writing files: the same as auxiliary on desktop platforms,
    but often a special directory on mobile platforms.

-   On Linux additionally it can load files from `/usr/share/lobster/` (or
    whatever path was configured for install by CMake, see `DATADIR`) if
    the above paths don't work. This is to allow package managers to install
    Lobster in the system directories.

Additionally, if any of these folders contains a `modules` directory, it will
load source code from there as well.

Any of the Lobster builtin commands that load data files specify paths relative
to either the main or auxiliary directories (and either / or \\ may be used as
path separators). If you package up a Lobster program for distribution, all
these files can be packed into a pakfile, see `--pak`.

Output
------

Running lobster may result in a compiler error, that generally look something
like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mygame.lobster(960): error: unknown identifier: highscor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If compiled correctly, running will give you output from your own print
statements, and additionally at some point may cause a runtime error, which can
look something like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pythtree.lobster(15): VM error: division by zero
in block -> pythtree.lobster(16)
   i = 0
in block -> pythtree.lobster(16)
in function: branch -> pythtree.lobster(29)
   poly = [[1.000000, 0.000000, 0.000000, 0.000000]:xyzw, [-1.000000, ...]:xyzw, ....]
   len = 4
   scale = 0.700000
   max = 11.000000
   n = 0
in block -> pythtree.lobster(29)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is called a stack trace. Besides the error and the line it happened on, it
will show all functions and blocks that called that code, in reverse order, with
any local variables and their values. This helps you get an idea where the
problem came from and helps in debugging.
</contents>
<source>
/tmp/tmpo9l8mwkb/engine.md
</source>
<contents>
---
title: Lobster built-in engine functionality
---

Lobster comes with "batteries included": a small (games/graphics) engine that allows you to start
drawing straight away. This doc collects some notes on the built-in functionality.

Basics
------
The basic list of [builtin functions](builtin_functions_reference.html) is worth
browsing first, as well as the [shooter tutorial](shooter_tutorial.html)
for some basic explanation of how to render stuff. Most examples in the `samples` dir
are graphical and provide further examples.

While it easy to render stuff with simple functions like `gl.rect`, `gl.line`
and stuff, for anything more advanced some understanding of OpenGL style
rendering is required.

Default rendering environment
----------------------------
After you call `gl.window` you are left with a default black background,
a white drawing color, and the `color` shader set.

Shaders
-------
All basic shaders, including `color`, can be found in `data/shaders/default.materials`.

You can use one of the many useful shaders from there with `gl.set_shader`,
but more fun is to use a custom shader. You can define these in-line in
your Lobster program as well, an example of that can be found in
`samples/custom_shader_metaballs.lobster`.

Lobster uses glsl shaders compatible with OpenGL 3+ and OpenGL ES 3+,
and you'll have to look elsewhere to learn the details of this language.

Lobster wraps these shaders in a custom declaration language, to cut down on
some of the boilerplate of putting a vertex and pixel shader together.

Lets look at the `textured` shader as an example:

```
SHADER textured
    VERTEX
        INPUTS apos:4 atc:2
        UNIFORMS mvp
        gl_Position = mvp * apos;
        itc = atc;
    PIXEL
        INPUTS itc:2
        UNIFORMS tex0 col
        frag_color = texture(tex0, itc) * col;
```

In all caps we have keywords that help declare these shaders for you.
We have a `VERTEX` and `PIXEL` part (alternatively, you could have only
a `COMPUTE` part).

The inputs to the vertex shader must match your vertex attributes, specify the
number of components you care about after `:`, and come from a fixed set of:

* `apos` (position, 2 or 3 components in the vertex buffer, but usually 4 in
  the shader to work with matrix transforms).
* `anormal` (3 components).
* `atc` (texture coordinate, 2 components).
* `acolor` (4 components)
* `aweights` and `aindices` (used with character animation).

The outputs of the vertex shader are automatically the same as the pixel
shader inputs, here `itc` (interpolated texture coordinate).

Using `UNIFORMS` you declare variables automatically provided by the engine:

* `mvp`: the Model View Projection matrix composed of the various `gl.scale`,
  `gl.translate` and `gl.rotate` transforms (the `mv` part) and the `gl.ortho`
  or `gl.perspective` transforms (the `p` part).
* `col`: set by `gl.color`.
* `camera`: position of the camera relative to the primitive being rendered.
* `light1` and `lightparams1`: set by `gl.light`.
* `framebuffer_size`: size in pixels.
* `bones`: see character animation shaders.
* `pointscale`: used with point rendering.

In addition you can add any custom uniforms with a `UNIFORM` declaration, for
example by adding `UNIFORM float time` to the shader and
`gl.set_uniform("time", gl.time())` you can animate your shader to the
current time.

Following these is the raw glsl implementing the shader. This is the body
of the shader, if you want to add additional helper functions, write
a `VERTEXFUNCTIONS` or `PIXELFUNCTIONS` block before the shader. The
functions declared here will be available to all shaders following it.

Additionally `DEFINE name val` defines macros to be used in the shaders below.

For compute shaders, e.g. `COMPUTE 8 8` at the end of the uniforms declares
the dispatch size.

Any more details, see `glshader.cpp` ;)
</contents>
<source>
/tmp/tmpo9l8mwkb/generate_html_docs_from_markdown.bat
</source>
<contents>
for %%F in (*.md) do pandoc -s -f markdown-smart -t html5 -c github.css -H head.html -o ..\%%~nF.html %%F
pause
</contents>
<source>
/tmp/tmpo9l8mwkb/generate_html_docs_from_markdown.sh
</source>
<contents>
for file in *.md
do
    base=${file%.*}
    pandoc "$file" -o "../$base".html -s -f markdown-smart -t html5 -c github.css -H head.html
done
</contents>
<source>
/tmp/tmpo9l8mwkb/getting_started.md
</source>
<contents>
---
title: Quick Getting Started Guide.
---


Get pre-built binaries (Windows, Mac, Linux)
-------------------------------------------

### Latest version from CI

If you don't want to deal with building it yourself, go to
[github CI](https://github.com/aardappel/lobster/actions?query=workflow%3ACI)
(click on the latest succesful run to get a list of binaries at the bottom).
These are 64-bit for all platforms.

Note: if you're NOT seeing a list of artifacts at the bottom of each run, that
may be because you're not logged in to github.

Now get https://github.com/aardappel/lobster (download zip).
This has all the data files and examples. Place the binary
you obtained in `bin` folder of the repo (not `/bin`).

### Releases

There may occasionally be builds on https://github.com/aardappel/lobster/releases
(`lobster_<date>_<platform>.zip` and `Source code (zip)`), but these are
usually way behind using the most recent builds above, so not recommended.


Or, build it yourself!
---------------------

### Linux

Pre-Requirements: Git, CMake, a C++17 compiler, Mesa dev files
(`apt-get install mesa-common-dev`).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
git clone https://github.com/aardappel/lobster.git
cd lobster/dev
cmake -DCMAKE_BUILD_TYPE=Release
make -j8
cd ..
bin/lobster samples/pythtree.lobster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Windows

Pre-Requirements: VS2022 Community edition or better, C++ desktop tools installed.

Get https://github.com/aardappel/lobster using your favorite git tool (best),
or just download a `.zip` from there otherwise.

Open `dev\lobster\lobster.sln`, ensure `Release` is selected in the top bar,
`Build -> Build Solution`, then close if no errors.

### Mac

Pre-Requirements: Latest XCode & CMake.

Get https://github.com/aardappel/lobster using your favorite git tool (best),
or just download a `.zip` otherwise.

From the terminal, in the `dev` folder, run `sh build_osx.sh` which will
generate an Xcode project in the `xcode-cmake` sub-folder.

Open `dev/xcode-cmake/Lobster.xcodeproj`, ensure `lobster > My Mac` is selected
as scheme in the top bar, `Product -> Build for -> Profiling` (to get a Release
build), then close if no errors.

Alternatively from the terminal from the `xcode-cmake` folder:

`xcodebuild -toolchain clang -configuration Release -target lobster`

Running it
----------

You now have a `lobster` executable in your `bin` folder.
You can run this with any Lobster file as argument to run it, for example
`bin/lobster.exe samples/pythtree.lobster` should work.

More Docs
---------

For more advanced usage, including how to run it from an editor,
check the rest of [the docs](README_FIRST.html)
</contents>
<source>
/tmp/tmpo9l8mwkb/head.html
</source>
<contents>
<link rel="icon" type="image/svg" href="lobster.svg" />
</contents>
<source>
/tmp/tmpo9l8mwkb/implementation.md
</source>
<contents>
---
title: The Lobster C++ Implementation
---

This document gives hints on how to work with the Lobster C++ code in terms of
building, extending, reusing, and compiling Lobster code to C++.

Lobster has been released under the Apache 2 open source license.

Building Lobster
----------------

Lobster uses recent C++17 features, so will need
Visual Studio 2022 (the free community edition will do), latest Xcode, or a very
recent GCC / Clang to be compiled.

Lobster uses OpenGL, SDL 2.x and FreeType, these are included in the repo, so should compile
out of the box with no further external dependencies.

All source code and other files related to building Lobster for all platforms
sit in the `dev` folder.

Lobster should be built for 64-bit platforms where possible. It will still also
build on 32-bit Wasm & Android. This does not affect Lobster
data type sizes, e.g. `int` and `float` types are 64-bit on all platforms.

Lobster can be built with a JIT (on desktop platforms, convenient during
development, as it can run Lobster source "instantly"), or by compiling to C++
(possible on all platforms, required on non-desktop), see below.

### Windows

Open up `dev\lobster\lobster.sln` with Visual Studio, and ensure `Release` mode is selected.
The project is set up to build lobster.exe in the `bin` folder, and will be ready for use
as described either from the [command line](command_line_usage.html) or [VS Code](vscode_ide.html) /
[SublimeText](sublime_ide.html) / [Notepad++](notepadpp_ide.html).

### OS X (& iOS)

You need to first generate the Xcode project using CMake, run `sh build_osx.sh`
from the `dev` folder, to generate an Xcode project in the `xcode-cmake`
sub-folder.

Open `dev/xcode-cmake/Lobster.xcodeproj`, ensure `lobster > My Mac` is selected
as scheme in the top bar, `Product -> Build for -> Profiling` (to get a Release
build), then close if no errors.

Alternatively from the terminal from the `xcode-cmake` folder:

`xcodebuild -toolchain clang -configuration Release -target lobster`

This results in a `bin/lobster` you can use.

To develop Lobster code on OS X, use the command line
version. Many OS X editors support running a command line compiler, e.g.
VSCode, SublimeText, or Komodo Edit with Tools -\> Run Command.

How to turn a Lobster program into an App Bundle for distribution: TBD
Need to see how to set this up using CMake.
You'll likely want to produce
a pak file (see [command line](command_line_usage.html)) to make sticking
this extra data in a bundle easier.

For iOS be sure to read how to compile to C++ below, since iOS doesn't
support in Lobster's default JIT mode.
How to make the above CMake project work for iOS: TBD.

### Linux

You can build with CMake on Linux:

This requires a C++17 compiler, and the mesa dev files
should be installed (`apt-get install mesa-common-dev`).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cd dev
cmake -DCMAKE_BUILD_TYPE=Release && make -j8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It creates `bin/lobster`. Run it to access the
samples, e.g. `bin/lobster samples/pythtree.lobster`

Note the `LOBSTER_ENGINE` CMake option, which is by default on. You can turn this
off to get a command-line only version of Lobster that does not depend on OpenGL,
SDL, FreeType etc.

### Android

Make sure you have the latest [Android Studio](https://developer.android.com/studio)
installed, and follow instructions to add the
[NDK](https://developer.android.com/studio/projects/install-ndk.md)

In Android Studio, use "Open" to open the `dev/android-project` dir.
It may complain about not knowing where the NDK lives, either let it fix this
automatically, or manually modify the path in `local.properties`

Using the desktop lobster exe, build your desired Lobster program using the `--pak`
option, such that all assets end up in a single file (see below for more information).
Place the result in `dev/android-project/app/src/main/assets/default.lpak` so
it will automatically be picked up by the build process and added to the APK.
Also compile your Lobster code to C++ as described below.

You should now be able to just press run. Wait for the build, and see it launch
on an attached Android device. Note that Lobster requires a device that supports
GLES 3.0 and Android version 4.3 (Jellybean). Emulators often do not support ES3,
you'll see a shader compile error in logcat if this happens.

If there are errors running, check logcat.

Things to change if you want to release your app in the Google Play store (these
instructions may be out of date):

-   Generate your own signing key with `keytool`. Make sure to also delete any
    old debug copy of the app from your device, or you’ll get a signature mismatch error.

-   Change the name to something else in `app/src/main/res/values/strings.xml`.

-   Change the .png files in `app/src/main/res/` with your own application icon.

-   You may want to change the package name from `org.libsdl.app` to your
    own. This needs to be done in 3 places, `app/build.gradle`, and
    `app/src/main/java/org/libsdl/app/SDLActivity.java` (both at the top of that file
    and the directory path itself!). Alternatively create a new class and inherit from
    `SDLActivity`.

### WebAssembly / Emscripten

You need the [Emscripten
toolchain](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html)
installed, as well as GNU make (on windows that means installing
[this](http://gnuwin32.sourceforge.net/packages/make.htm)).

Before you build, gather your lobster distribution files (see below) and place
them in `dev/emscripten/assets`. They will be automatically picked up by the
build process this way.

The Wasm implementation does not support the JIT, so you should first
compile your `.lobster` code to C++, as described in the
section "Compiling Lobster code to C++" below.

To build, go to `dev/emscripten`, and type `make -j8`. This should produce a
lobster.[wasm\|js\|html\|data] in the same directory (the latter containing whatever
you placed in `assets`).

You can now run it with `emrun --browser chrome lobster.html --verbose` or
if that doesn't work, `emrun --no_browser lobster.html --verbose` and
manually navigate to `http://localhost:6931/lobster.html?--verbose` in your
browser. Note that just loading up the html in your browser directly may not
work because of security restrictions. Alternatively place all the generated
files on a webserver, and load from there.

Distributing Lobster programs.
------------------------------

While the above instructions will build you the lobster executable, to
distribute a Lobster program to others, you will need to distribution files.
These must be (including correct paths):

-   `default.lpak`. This is the Lobster pakfile file you obtain from compiling
    your program with the `--pak` option, it includes:

    -   The bytecode.

    -   `data/shaders/default.materials` (these are the minimum shader definitions
        needed for to render anything, and is implicitly loaded by `gl.window`).

    -   Any other files/directories you have specified with `pakfile`, e.g:
        `gl.load_texture(pakfile ”mypath/myfile.png”)`. `pakfile` can prefix
        filenames or directories (ending in `/`), in which case all files in the
        directory will (non-recursively) be added. You can specify a filter with
        `#foo` at the end of a pakfile string which causes only filenames that
        contain `foo` to be added. When running with `--verbose`
        you can see what files are added/loaded from a pakfile, and which are
        loaded individually.

-   Any files your code references that are not in the pakfile (e.g.
    `gl.load_texture(”mypath/myfile.png”)` ).

-   On Windows, you’ll need to include `bin\openvr_api.dll` and/or `bin\steam_api.dll`
    next to `lobster.exe` ONLY if you use functions starting with `vr.` or
    `steam.` respectively.

Where you place these files depends on the platform, on Windows / Linux it is
next to the lobster executable, on OS X / iOS it is the application bundle under
Contents, on Android it’s under assets in the .apk, and with Emscripten there’s
an assets directory also.

Compiling Lobster code to C++
-----------------------------

Rather than directly executing with a JIT, Lobster can also be
translated to C++, for a further speed boost. This is useful when releasing a
shipping build to customers, but hopefully not necessary during development.
It is necessary for building for mobile/web platforms.

With the `--cpp` option on the command-line, the compiler will generate
`dev/compiled_lobster/src/compiled_lobster.cpp` (currently, you MUST compile
it from the root of the repo, e.g. `bin/lobster --cpp somepath/my.lobster`,
otherwise this will likely fail).
This file contains a `main()` and is otherwise
self-contained such that when you compile it with the build files for any
platform (see instructions above) substituting it for the standard `main.cpp`,
you’ll end up with an executable that runs only that specific program.

On Windows, there are project files in `dev/compiled_lobster` that will
automatically pick up the compiled lobster code.

On Linux, building in `dev` like above, then instead
`cmake -DLOBSTER_TOCPP=ON -DCMAKE_BUILD_TYPE=Release .` will automatically
substitute the compiled lobster main program. Build with `make -j8` or similar.

For Emscripten, there's a `cpp` make target (which is the default).

Extending Lobster
-----------------

Besides using Lobster as a stand-alone programming language as-is, there are 2
ways of extending Lobster, by adding your code to Lobster, or adding Lobster to
your project.

Note that unlike other scripting languages, Lobster has been designed as a
stand-alone language first, rather than a plug-in scripting system (more like
Python and Ruby, not like Lua and UnrealScript). You use Lobster code as your
"main program", with the "engine" being the library you call into. Most game
engines are the opposite: the engine code is the main program, and the scripting
language is being called into. For that reason, adding your own code to Lobster
is by the far the preferable way of building an application that uses Lobster,
and will generally be a much more productive environment.

The thinking here is that you use C++ purely to write performance critical code,
which can usually be contained in libraries. For the non-performance critical
code, which includes the general setup of your main program determining how
things fit together, you are much better off using a friendlier language, like
Lobster. It means that changing the structure of your project is much quicker,
and it is easier to experiment with new game ideas based on your C++ libraries.
Iterations in Lobster can be done more rapidly and more safely, often in less
code, than C++.

### Adding your code to Lobster

Depending on what you want to write, the current engine functionality of Lobster
may not be sufficient. Lobster adds C++ functions to the language in a modular
fashion, in the Visual Studio project you can see all things added to Lobster in
2 places:

-   The "builtins" folder, which should really be part of any Lobster
    implementation. `buitins.cpp` is the most important one that adds
    vector & math operations etc., without which the language would
    be hard to use. `file.cpp` adds file I/O related functions, and
    `lobsterreader.cpp` allows you to parse data structures in lobster syntax
    from a running program.

-   The engine folder. This contains all graphics/font/audio etc functionality.
    `graphics.cpp` / `font.cpp` build on top of the above mentioned 3 libraries,
    and can either be kept, or replaced entirely by functions that use a
    different rendering system. You can turn Lobster into a console-only
    language in one step by simply removing the engine folder from the project.

You can always run Lobster with the `--gen-builtins-html` option to get an overview of all
functions currently added to the system (the current list is
[here](builtin_functions_reference.html)). To add/remove functionality is
generally as easy as adding/removing the corresponding `.cpp` file.

Lobster uses some macros to allow you to define a native function in one
location without declarations needed elsewhere. To learn how to write your own
.cpp of native functions, best to start with a simple example, such as
`audio.cpp`, then browse through more complex examples in `builtin.cpp` and
`graphics.cpp`.

Here's a simple example of a Lobster extension:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include "lobster/stdafx.h"

#include "lobster/natreg.h"

using namespace lobster;

void MyNativeOps(NativeRegistry &nfr) {

    nfr("add", "x,y", "II", "I",
        "Adds two integers.",
        [](StackPtr &, VM &, Value x, Value y) {
            return Value(x.ival() + y.ival());
        });

    // more such declarations here
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You'll need to become somewhat familiar with the Lobster internals to write
these functions successfully, in particular with the `Value` type (see
`vmdata.h`), which is a union of all possible lobster types. If you specify
specific types (such as `I` for `int`, `F` for `float`, `S` for `string`, `V`
for `vector` etc (more details in `natreg.h`),
then the `Value` will already have been typechecked and
guaranteed to be that type, such that you can directly access the component
(e.g. `.ival()`) without checking the type (you'll get an assert if you get this
wrong).

As you can see, even the help text is included in the declaration, so everything
related to the function is in one location.

Important is dealing with memory management: by default, you *borrow* all
arguments, meaning you're not supposed to keep a pointer to them after the
function ends. If you return a value that was allocated (see e.g. `VM::NewString`)
then the caller will own this value. This is typically what you want.
If for whatever reason you want to hold on to a value, have a look at functions
that do so, like `push`.

In designing your extension library, if you intend to add a lot of functions, it
is a good idea to choose a namespace (similar to `gl.` for all the graphics
functionality) to all your functions. Lobster uses `_` for namespacing also in
the language. The burden on making sure there are no name clashes is on the
programmer integrating new libraries (you will get an assert if 2 names ever
clash).

Now from your main program, you'll need to call
`RegisterBuiltin(nfr, "name", MyNativeOps)` or similar before you invoke the
Lobster compiler, such that these new functions are available during all
compiler passes.

You can add the above file to whatever build system you're using, but that
may involve modifying the Lobster project files which you may not want to do.
Instead, if your extension is small enough to sit in a header file, you can
make use of the automatic inclusion of `projects/include/lobster_engine_plugins.h`
(see comments in `engine.cpp`) which will then automatically be picked up as
part of any Lobster build.

### Adding Lobster to your project

This should still be fairly easy, as Lobster was made to be fairly modular, but
is a bit more work than above. I will strive to make this path easier in the
future.

With the CMake project, this is easy, as all `LOBSTER_ENGINE=OFF` will get you
a Lobster build without the built-in engine, the result you can add to your
own projects. You'll likely want to replace `main.cpp` with something that
runs Lobster from your own code.

Similarly, in the visual studio project, there is the `language` project,
which is what you'd want to include in your own projects, and the `engine`
project which you are replacing. Finally there's again `main.cpp` to adapt.

Some of Lobster relies on its own math library (`geom.h`), but it should be
very easy to make convenient functions to convert Lobster vectors into your own
math types (you could wrap around the `ToValue` and `ValueTo` functions).
</contents>
<source>
/tmp/tmpo9l8mwkb/implementation_wasm_REMOVED.md
</source>
<contents>
---
title: The Lobster WASM code generator implementation
---

**NOTE: THIS FUNCTIONALITY HAS BEEN REMOVED (Wasm now builds thru C++), this doc is here for
historical reference but should otherwise be ignored.**

**NOTE: this document contains detail on how code generation for the
WebAssembly backend works internally, if you just want to USE this backend,
please read the sections on WebAssembly [here](implementation.html).**

This document is also meant to be useful for implementors of other languages
that may wish to do something similar (and could re-use Lobster's
[WASM binary writer](https://github.com/aardappel/lobster/blob/master/dev/src/lobster/wasm_binary_writer.h) ).

Structure of the backend
------------------------
Lobster is structured such that the front-end outputs Lobster bytecode,
which sits in a FlatBuffer file together with all its metadata. That file
is stand-alone (does not need any further information from the front-end
or source code) and can be interpreted by the VM directly, or passed to
any of the native code backends, currently C++ or WebAssembly.

The backend is composed of these 2 files:

* [`towasm.cpp`](https://github.com/aardappel/lobster/blob/master/dev/src/towasm.cpp)
  It parses the Lobster bytecode does all the Lobster-specific
  work of generating wasm code.
* [`wasm_binary_writer.h`](https://github.com/aardappel/lobster/blob/master/dev/src/lobster/wasm_binary_writer.h)
  is a utility class that does all the heavy lifting
  of actually generating a valid wasm module. It is written such that it is
  entirely independent of the rest of the Lobster code base, and depends only
  on a few STL containers, to ensure it can easily be adopted by others
  wishing to emit wasm. It contains functionality for low level encoding
  (LEBs etc), emitting sections, individual instructions, and importantly,
  linking and relocation information.
  [`wasm_binary_writer_test.h`](https://github.com/aardappel/lobster/blob/master/dev/src/lobster/wasm_binary_writer_test.h)
  is a simple test of this functionality, and
  may also serve as a more complete example than the small example below.


Design of the binary writer
---------------------------
Most languages, like Lobster, come with a runtime in C or C++ that you wouldn't
want to translate to wasm by hand (or worse, emit instruction by instruction
from a backend), so it is important that generated wasm code can be linked
correctly against a runtime compiled to object files by the C/C++ compiler.
In this case we're piggy-backing on Clang, LLD and Binaryen as used in the
Emscripten toolchain.

This means generating a wasm module with linking information, and supplying
the right relocations. Many instructions in wasm refer to functions and other
things by index, but the linker has to merge many such index spaces into
the final module, which means renumbering all of these indices. Luckily, the
binary writer takes care of all this automatically, and allows us the generate
code as-if we're the only object file.

### Streaming interface.
The binary writer is a "streaming" API (as opposed to an object
API), meaning that it immediately writes out the wasm module data with no
or few intermediary data structures. This has the advantage that it is
low in memory usage and is very fast, with the downside being that most
things have to be supplied to it in order. This should not be very difficult
for most code generators, however.

A wasm module should contain sections in order, and the API enforces
this same order:

~~~~
Type     1    Function signature declarations
Import   2    Import declarations
Function 3    Function declarations
Table    4    Indirect function table and other tables
Memory   5    Memory attributes
Global   6    Global declarations
Export   7    Exports
Start    8    Start function declaration
Element  9    Elements section
Code    10    Function bodies (code)
Data    11    Data segments
~~~~

What is not shown here is custom sections, which may appear before and
after each of these sections. One such custom section is the linking
section, which appears at the end of all of the above. Its contents is
generated automatically by the binary writer as a consequence of all the
things emitted in the above section (primarily the Code section).

### Simple example.

A minimal usage of the API, where we generate code for "hello world",
assuming the printing function is in the runtime.

Note that this assumes a minimum familiarity with wasm in general.
I am not going to explain the "why" of this design, if you end up using
this API then reading up on the wasm module format would be useful.

~~~~cpp
vector<uint8_t> bytes;
WASM::BinaryWriter bw(bytes);

// Write a (function) type section, to be referred to by functions below.
// For any of these sections, if you write them out of order, or don't match
// begin/end, you'll get an assert.
// As with everything, to refer to things in wasm, use a 0 based index.
bw.BeginSection(WASM::Section::Type);
// A list of arguments followed by a list of return values.
// You don't have to use the return value of AddType, but it may make referring
// to these types easier.
auto type_ii_i = bw.AddType({ WASM::I32, WASM::I32 }, { WASM::I32 });  // 0
auto type_i_v = bw.AddType({ WASM::I32 }, {});  // 1
bw.EndSection(WASM::Section::Type);

// Import some functions, from the runtime compiled in other object files.
// For our example that will just be the printing function.
// Note: we assume this function has been declared with: extern "C"
// You can link against C++ functions as well if you don't mind dealing
// with name mangling.
bw.BeginSection(WASM::Section::Import);
auto import_print = bw.AddImportLinkFunction("print", type_i_v);  // 0
bw.EndSection(WASM::Section::Import);

// Declare all the functions we will generate. Note this is just the type,
// the body of the code will follow below.
bw.BeginSection(WASM::Section::Function);
bw.AddFunction(type_ii_i);  // main()
bw.EndSection(WASM::Section::Function);

// Declare the linear memory we want to use, with 1 initial page.
bw.BeginSection(WASM::Section::Memory);
bw.AddMemory(1);
bw.EndSection(WASM::Section::Memory);

// Here we'd normally declare a "Start" section, but the linker will
// take care for that for us.

// Now the exciting part: emitting function bodies.
bw.BeginSection(WASM::Section::Code);

// A list of 0 local types,
bw.AddCode({}, "main", false);
// Refer to data segment 0 at offset 0 below. This emits an i32.const
// instruction, whose immediate value will get relocated to refer to the
// data correctly.
bw.EmitI32ConstDataRef(0, 0);
bw.EmitCall(import_print);
bw.EmitI32Const(0);  // Return value.
bw.EmitEndFunction();

// Here, call AddCode..EmitEndFunction for more functions.

bw.EndSection(WASM::Section::Code);

// Add all our static data.
bw.BeginSection(WASM::Section::Data);
// This is our first segment, we referred to this above as 0.
auto hello = "Hello, World\n\0"sv;
// Data, name, and alignment.
bw.AddData(hello, "hello", 0);
bw.EndSection(WASM::Section::Data);

// This call does all the remaining work of generating the linking
// information, and wrapping up the file.
bw.Finish();

// Here, we can write the contents of "bytes" above to a file.
// Then, using emcc to link print.c and generated.o should actually
// produce a valid module!
~~~~

The binary writer API contains functionality for many more instructions
and sections, best to have a browse through
[`wasm_binary_writer.h`](https://github.com/aardappel/lobster/blob/master/dev/src/lobster/wasm_binary_writer.h)
and
[`wasm_binary_writer_test.h`](https://github.com/aardappel/lobster/blob/master/dev/src/lobster/wasm_binary_writer_test.h)
which are both fairly small, so should give a good impression what else you
can generate.


### The Lobster generator.

A more complex example using the binary writer is the Lobster generator
in [`towasm.cpp`](https://github.com/aardappel/lobster/blob/master/dev/src/towasm.cpp),
which follows the same pattern as the above simple example.

In terms of imports, it imports one function for each of Lobsters bytecodes,
which means a Lobster bytecode can be directly mapped to a function id.
Then there are a couple of additional functions in the runtime it needs,
most importantly `EngineRunCompiledCodeMain` which it calls with the starting
compiled function, such that runtime can initialize itself and then call
back into the Lobster compiled code. This structure was chosen such that
the maximum amount of code can live in the runtime, and the minimum needs
to be explicitly generated.

It generates Lobster code not on a per function basis, but per basic block.
This is because Lobster has more complicated control flow features (such
as non-local returns and co-routines) which (at the time of writing)
wasm can't support natively. So it uses a "trampoline" system where each
basic block returns the function address of the next basic block it wants
to go to. Some of these transitions can be optimized (and the generator
does use tail calls in many cases), but in the most general case this has
to be an indirect jump.

The actual instructions generated are pretty simple, with it mostly
emitting a call per VM instruction, with the exception of control flow
operations which have more special purpose implementation.

You would expect it to directly emit wasm instructions like `i32.add` for
simple Lobster bytecode instructions like `IL_IADD`, but it doesn't, for
various reasons. First, we rely on Binaryen to do whole program optimisation
(similar to LTO) after linking (since the we're calling the implementation of
bytecode instruction that sits in a different object file). This means that if the
implementation of a bytecode instruction is trivial, it will get inlined,
saving us the trouble of doing so. The second reason is more complicated:
Lobster currently has all of its variables on its own stack (where it can
do custom management of it, required for e.g. its memory management, non
local return features). Instructions like `i32.add` instead
expects values on the wasm stack. So maximum benefit of emitting such
instructions directly would only be achieved if (a subset of) Lobster
variables could be moved into wasm locals first. That is a more extensive
optimization that may be added in the future.

Speed of code produced by this backend is almost competitive with code that
instead goes through the C++ backend (which is quite a feat, as the C++ code
goes through the entire LLVM optimisation pipeline, and the WASM backend does
not). One area where it can seriously slow down is exceptions, which are
currently not natively implemented in WASM (they go through an indirection
in JS) and the Lobster runtime relies on them for error handling, and even
frame termination. This problem will be solved when WASM gains native
exceptions, or when the runtime is able to execute without exceptions (which
would cause some overhead of its own).
</contents>
<source>
/tmp/tmpo9l8mwkb/language_reference.md
</source>
<contents>
---
title: Lobster Language Reference
---

This is the definition of the language that tries to be a more exact a
description of how the language works (the most exact description, however, will
always be the source code :) ). As such, this is not the easiest way to learn the
language, start with a tutorial first, and then use this for more difficult
questions.

Syntactically Lobster tries to follow a mix of Python and C conventions where
possible, but has a lot of unique syntax too.

Lexical definition
------------------

-   Whitespace is space, tab, carriage return, nested comments delimited by `/*`
    and `*/` or single line comments starting with `//`

-   Operator tokens are `( ) [ ] { } : , & | + ++ += - -- -= * *= / /= % %= ==
    != < > <= >= <- = ? . -> ^ << >>`

-   Strings delimited by `"` and character constants with `'` using escape codes
    `\n \t \r \" \' \ \x` (followed by 2 hex digits, e.g. `\xFF` is the
    character with value 255). Alternatively, strings can be enclosed in
    triple-quotes (`"""`) and may then contain any characters verbatim,
    including new-lines, quotes, and escape codes (which are all left
    untouched).

-   Numbers consisting of a series of digits to indicate an integer constant
    (e.g. `123`) or hex digits with a leading `0x` (e.g. `0xABADCAFE`) or digits
    with a single `.` (e.g. `.1` or `1.` or `1.1`) to indicate a floating point
    constant.

-   Identifiers made from alpha-numeric characters and the `_` (except no digits
    for the first character).

-   Keywords: `nil return class struct import int float string any void
    def fn is from program private resource enum enum_flags typeof
    var let pakfile switch case default namespace not and or attribute
    if for while super constructor guard abstract member member_frame
    static static_frame attribute operator`

-   Linefeed is whitespace if it follows a token that indicates an incomplete
    expression (such as `+` or `,`) and an actual token otherwise (used to
    separate lists of expressions inside a block, see below).

-   `indent` and `dedent` tokens are generated whenever the indentation level
    changes. Indentation of any 2 adjacent lines must start with the same
    sequence of spaces and/or tabs. This ensures it is impossible to create
    indentation that behaves differently from the way it looks visually.

Grammar
-------

Below, `...` indicates a loop with exit point at that scope level (ex. `(ident ... ,)` -> `(ident (, ident)*)`, * meaning optionaly repeating),
and `||` is like `|` except indicates a precedence level difference. `[rule]` Means optional.

program = stats end\_of\_file

stats = topexp … linefeed

topexp = `namespace` ident
      \|`import` [ `from` ] ( string\_constant \| ( ident ... `.` ) )
      \| [ `private` ] ( functiondef \| class \| vardef \| enumdef )
      \| `guard` condexp [ `:` body ]
      \| expstat \| attrdef

class = ( `class` \| `struct` ) ident
        ( `=` ident specializers
       \| [ generics ] `:` [ ident [ specializers ] ]
          indlist( ident [ `:` type ] [ `=` exp ] \| functiondef ) )

specializers = `<` list( type ) `>`

generics = `<` list( ident ) `>`

vardef = ( `var` \| `let` ) list( ident [ `:` type ] ) `=` opexp

enumdef = ( `enum` | `enum_flags` ) ident `:` indlist( ident [ `=` integer\_constant ] )

functiondef = ( `def` | `constructor` ) ident [ generics ] functionargsbody

functionargsbody = `(` args `)` `:` body

block = [ args ] `:` body \| functionargsbody

args = [ list( ident [ ( `:` \| `::` ) type ] [ `=` exp ] ) ]

body = ( expstat \| indent stats dedent )

type = `int` \| `float` \| `string` \| `[` type `]` \| `resource` `<` ident `>` \| `void`
\| ident [ specializers ]

call = [ specializers ] `(` [ list( exp ) ] `)` [ block [ `fn` block … ] ]

expstat = exp \| `return` ( [ list( opexp ) ] ) [ `from` ( `program` \| ident ) ] \|
`for` exp `:` body \| `while` condexp `:` body

condexp = exp \| vardef

exp = opexp [ ( `=` \| `+=` \| `-=` \| `*=` \| `/=` \| `%=` ) exp ]

opexp = unary [ ( `*` \| `/` \| `%` \|\| `+` \| `-` \|\| `<` \| `>` \| `>=` \|
`<=` \|\| `==` \| `!=` \|\| `&` \| `|` \| `and` \| `or` \| \^ \|
`<<` \| `>>`) unary ]

unary = ( `-` \| `++` \| `--` \| \~ \| `not` ) unary \| deref

deref = factor [ `[` exp `]` \| `.` ident [ call ] \| `->` ident
\| `++` \| `--` \| `is` type ]

factor = constant \| `(` exp `)` \| `super` \| `if` ifpart \| `assert` condexp \| pakfile string\_constant \|
constructor \| `fn` functionargsbody \| ident [ call ]

ifpart = condexp `:` body (`else` `:` body \| `elif` `:` ifpart)

constructor = `[` [ list( exp ) ] `]` [ `::` type ] \| ident `{` [ list( ident `:` exp \| exp ] `}`

constant = numeric\_constant \| string\_constant \| character\_constant \| `nil` [ `::` type ]

attrdef = `attribute` ident [ `=` ( string\_constant \| numeric\_constant \| ident ) ]

indlist(e) = indent list(e) [ linefeed ] dedent linefeed

list(e) = e ... `,`

Types
-----

Lobster is statically typed, and any variable, argument or vector element can be
a value of one of the following types:

-   Scalar types (64-bit on all platforms):

    -   `int` : a signed integer. Constructed using:

        -   integer constants : `123`

        -   hexadecimal constants : `0xABADCAFE`

        -   character constants : `'A'` (65)

        -   default boolean values `true` and `false` (same as `1` and `0`)

    -   `float` : an IEEE floating point number

    -   a function value, can be called just like normal functions. See below.

-   Reference values:

    -   `string` : a vector of byte sized elements, generally used to store
        text, but can store any byte array. The recommended format for text is
        UTF-8, though this is not enforced; indexing and size operations act on
        bytes. To properly manipulate unicode symbols, UTF-8 strings can be
        converted to vectors of uncompressed unicode values using the built-in
        functions string_to_unicode and unicode_to_string. Immutable: can be indexed
        into for reading but not writing.

    -   vector : a dynamically sized array of any Lobster values, constructed
        with square brackets surrounding 0 or more comma separated values, e.g.
        `[ 1, 2, 3 ]` for which the element type is also surrounded in square
        brackets, e.g. `[int]`. May be dereferenced for reading/writing using indices
        (e.g. `a[0]`). Vectors may be typed by being suffixed by `::type`, which
        will require all elements to be of that type (also useful to force a type
        on an empty list).

    -   `class` / `struct` : a user defined data structure, see below.

    -   `nil` : a special value of any reference type above, that indicates the
        absence of a legal value. `nil` is only allowed if the type is
        "nilable", for more on that see the document on type checking,
        [here](type_checker.html). Since just `nil` doesn't make it obvious
        what type you are referring to, you can use e.g. `nil::string` to
        specify a value of type `string?` (a type that denotes the value can be
        a string or nil), though in most cases type inference makes writing
        just `nil` sufficient.

    -   `resource<T>` : an opaque object managed by the engine / C++ code.
        `T` is the type, e.g. `texture` or `mesh`, the availability of these
        depends on what engine functionality is linked in to Lobster, see
        `builtin_functions_reference.html` for what functions create and use
        these resources. Their lifetime is managed by the language much like
        other reference types above.

Lobster does not have a built-in boolean type, though it does have a pre-defined
`bool` enum (see enums below). In general, for boolean tests such
as the `not and or` operators (see below) or control structures `if` `guard` `while` `assert`, the values
`0 0.0 nil` (which includes the enum value `false`) are all considered to be false,
and all other values are true.

The vector and `class` types are the only mutable objects (can
change after creation), and have reference semantics (multiple values can refer
to the same object in memory, and thus changes can be observed from each).

User Defined Types
------------------

The `class` and `struct` keywords allow you to define a user defined type. For
example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct int2:
    x:int
    y:int

struct int3 : int2
    z:int
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use either `class` or `struct` to define these, with the latter being more
restrictive: they are stored in-inline in their parent and copied.
This makes sense for small objects such as the one in this example.

You specify a list of fields using indentation.

Optionally, you specify a supertype, which has the effect of adding all the
fields of the supertype to the current type, thus making it an extension of the
former.

The above example uses ints directly, but you
can also define types more generically, and then define named specializations of them:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct vec2<T>:
    x:T
    y:T

struct int2 = vec2<int>
struct float2 = vec2<float>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You construct values of these types you use a similar syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let v = int2 { 1, 0 }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(Or use `float2 { 1, 0 }` / `vec2<bool> { true, false }` to explicitly pick a different
specialization).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct float2:
    x = 0.0
    y = 0.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Additionally, you may specify default values, if these are given, then these
values are not arguments to the constructor, e.g. `float2 {}`.

For more complex structs, you can use field names as "tags" in a constructor
call, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
float2 { x: 1.0, y: 2.0 }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides being more readable, it allows you to specify the fields in any order,
and to override fields that have defaults.

The constructor type may also be omitted, in contexts where that type is clearly
known, such as inside other constructors, explicitly typed function calls and variables.
For example, if `foo` is known to take a `float2` argument, you may write
`foo({ 1.0, 2.0 })` instead of `foo(float2 { 1.0, 2.0 })`.

For more complex ways of constructing types, see constructor functions below.

To declare a type whose only purpose is to serve as a superclass for other
types and is not to be instantiated, declare it with `abstract`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
abstract class Node
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Operators
---------

Lobster comes with a set of built-in operators mostly familiar from other
languages that attempt to work on as many of the above types as makes sense. In
particular, unlike most languages, many of them work on (numeric) structs, which
makes typical game code both convenient and fast.

### Assignment and Definition

The assignment operators simply copies the value on the right hand side into the
variable or vector index on the left hand side:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a = 1
v[0] = 1
v.x = 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All variables must already have been declared, or this will result in an error.
`var` defines and assigns in one go, and requires the variable to not
have been declared yet in this scope. `let` does the same for variables which
cannot be modified afterwards:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var a = 1
let b = 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var d, e = 1, 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As you can see in the last 2 lines, all of these operators also
allow multiple values to be assigned at once (see also multiple return values
below).

### Indexing

As indicated, square brackets can be used to index into vectors, and similarly
`.` can dereference fields of a `class` or `struct`.
These may be chained arbitrarily.

You may even use a vector as index, e.g.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let mat = [ [ 1, 2 ],  [ 3, 4 ] ]
let pos = int2 { 0, 1 }
print mat[pos]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This prints `3`, and is a convenient shortcut for `mat[pos.y][pos.x]`. Note how
it uses the last element to index with first, this is because in code and other
places 2d arrays are usually most naturally thought of as row-major.

### Mathematical Operators

The 5 binary mathematical operators `+ - * / %` (the last 3 having higher
precedence) work on `int`, `float` (or a combination, where the end result will
be `float`). They also work on structs containing ints or floats with either
another struct or a single int or float. These structs must be the same type.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int2 { 1, 2 } * int2 { 4, 5 }  // results in int2 { 4, 10 }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All 5 also have have a combined assignment operator version, `+= -= *= /= %=`,
which are implemented to have exactly the same effect as their expanded form,
e.g. `a += 1` is always exactly the same as `a = a + 1`.

In addition, the `+` operator also works as string concatenation if either side
is of string type (the other side will be converted to a string representation
if it wasn't already), though in most cases you should prefer to use
string interpolation (see below).

Unary minus (`-`) acts on the same types in the same way as the binary version.

The increment and decrement operators `++` and `--` work either as prefix
(increment, return new value) and as postfix (increment, return old value) on
any lvalues.

Bitwise operators `& | ^ ~ << >>` behave like they do in any other language.

### Comparison and Logical Operators

The next lower level of precedence are the comparison operators `< > <= >=`
which work on `int`, `float` and `string` and structs (returning a struct of
ints, use builtin functions `any` and `all` to test these), and then the
equality operators `==` and `!=` which additionally work on all other types, but
in particular for `vector` and `class` compare *by reference*, i.e they will
give true only if both sides refer to the same object (*object identity*). To
test for *structural identity* instead, use the built-in function `equal`.

The logical operators `and` and `or` are the next lower level of precedence,
and both short-circuit: `a or b` returns `a` if it is not a false value (one
of `0 0.0 nil`), and `b` otherwise. `a and b` returns `a` if it is a false
value, `b` otherwise. The unary operator `not` turns false values into `1`
and others into `0`.

The `is` operator returns true if the left hand side value is of the type
specified on the right, e.g. `x is float`.

Function Definitions
--------------------

Lobster's entire design centers around functions and how they can be composed.
It has both *named functions* and *function values*.

### Named Functions

Named functions can be declared at any scope level (may be local), like so:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def name(arg1, arg2): body
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`body` can either be a single expression, or, most commonly, an indentation
(start of code on the next line further than the previous line,
in this case the `def` keyword), and
then any number of expressions on their own line separated by linefeeds, until a
de-dedentation occurs (return to the indentation level of the parent, in this
case again the `def` keyword). It is an error to de-dedent less than the parent
level. For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def name(arg1, arg2):
    exp1
    exp2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The return value of a function is determined by its `return` statements (see
below) or `void` (no return value) otherwise, except for anonymous functions,
which don't need an explicit `return` (it is automatically the last expression
evaluated).

Arguments can be just an argument name (which will be available as a lexically
scoped local variable inside body), or a typed name (e.g. `s:string`).
If you don't specify types, the function is generic,
meaning it will receive types from the caller. If called with multiple
combinations of incompatible arguments, you automatically get multiple
"specializations" of the same function, meaning working with different types
is very easy. Alternatively, you can specify generic types explicitly as well
(more in [type system](type_checker.html)).

You can use :: instead of : for typed class/struct arguments, which allows you to
access all fields / functions of that object directly, without having to prefix
them with the argument name, e.g.:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def magnitude(v::float2): return sqrt(x * x + y * y)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also leave out the `v::float2` entirely if you define this function as part
of a `class` / `struct` definition of type `float2` (see above). Both types of
definition are equivalent.

You can specify an explicit return type, like so:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def f(a:int, b:int) -> float: return a + b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is typically not necessary, but may be helpful when coercing to a more
general type.

### Function calls

Functions can be called as part of an expression with a similar syntax to its
definition, e.g. `name(1, 2)`. Alternatively, you may use the `.` notation to
place the first argument ahead of the call, for example `1.name(2)`. If you are
using the `.` notation with a function that has just one argument, the `()` may
be omitted, `v.length` being a common example. You are encouraged to only do
this for simple functions that return a property of the argument, and don't
modify the argument.

Optionally, you may also call functions without any parentheses at all, e.g.
`print "hi!"`. This is only allowed for known functions (that are not ambiguous
with variables) that have 1 expression argument (followed by any number of
function value arguments that don't take arguments themselves, see below). It is
up to the programmer to use good judgement on when to use this, the recommended
use case is for calls used as statements (no nesting) that don't cause
additional parentheses to be needed elsewhere. In case of doubt, use the
standard call syntax.

### Function Values

You can also create anonymous (nameless) functions as values. In the most
general case, this has the syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let f = fn(a:type, n:type): body
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Or, if you are not specifying any types:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let f = fn a, b: body
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You call these just like any other function, e.g. `f(1, 2)`. You currently
must call them using a variable (not any expression, not even a field).

The full `fn` syntax is infrequently used however, because most function
values are created to be passed to other functions, and Lobster has a special
syntax for this situation that is meant to mimic control structures in other
languages. Any function call may be followed by one or more function values,
where the `fn` keyword is omitted:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g(10) i: print(i)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here, the function `g` is called with 2 arguments, the first is `10`, and the
second is the function value `fn i: print(i)` (as before, we left out the
the `()` around the arguments). Lobster allows yet further simplification of
the syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g(10): print(_)
g 10: print _
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may use anonymous arguments, which
are variable names starting with an `_` that will automatically be declared as
arguments for you. If you use multiple such arguments (e.g. `_a` and `_b`), they
will become arguments in the order they appear in the body. Using anonymous
variables is only recommended for very simple function bodies.

As mentioned above, you may drop the parentheses entirely if the body doesn't
have any argument declarations.

This style of syntax is intended to make each function that takes a function as
argument (a *higher order function*) have the convenient syntax of a control
structure, since that's what those functions usually are meant to be anyway.
Lobster's  built-in control structures `if` `for` and `while` have syntax
that is closely compatible with this function call syntax (and in the case of
`for` allow the same argument simplifications).

The return value of these functions is the last expression in `body`. You don't
use explicit `return` statements, as those are used with the enclosing named
function instead, see "Explicit Returns" below.

Though not recommend (as readability suffers), it is even possible to pass
multiple function values to a function, but then every function value except the
first can't omit the `fn` keyword:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g(10) i:
    print i
fn:
    print "reached the end"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For example, to pass an additional function to do something special at the end of
an iteration.

Writing your own functions that take function values is the key to getting the
most out of Lobster. It allows you to refactor pretty much any code into
something that has no redundancy yet is easy to create, use and modify.

Typically, to write a function that takes a function value argument, simply
use an argument with no type:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def twice(f):
    for(2): f()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, you may want to be explicit about the function type. You can declare
new function types, and then use them as a type:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def function_type(i:int) -> int
def g(f:function_type): return 1 + f(2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides enforcing the type of function that can be passed (which makes for more
readable errors when it fails), it also forces the function passed to not be inlined
(which may reduce code-bloat if functions taking this function type are called
many times, at a minimal hit in speed). Function values called over a generic
variable are always inlined (since they represent a unique function type even
if its signature is accidentally the same as another function value), to ensure
higher order functions are competitive in speed with hard-coded equivalents.

Lobster really wants you to be able to use function values everywhere at no
cost, so besides guaranteed inlining, the other way they differ from other
languages is that they are always *non-escaping*. What that means is, that
while function values may use free variables (refer to variables from enclosing
scopes), they are not "closures", i.e. they do not close over (capture) these
variables, they merely refer to them. This means these function values cannot
be called from an environment where those free variables are not available
anymore (this will typically result in a compile-time error). This makes a
function value in Lobster a single code pointer without any variable information
attached, and thus extremely cheap. The downside is that they can't be used
for things like certain kinds of callbacks, though you probably shouldn't be
using those in game-like contexts anyway ;)

### Explicit Returns

Using `return` you return from the closest lexically enclosing named function,
e.g.:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def find(list, x):
    for list:
        if x == _:
            return true
    return false
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`find`'s return value is `false` unless the nested `return` gets evaluated, and
then it becomes `true`. Importantly, `return true` is an expression that sits
inside a function value being passed to `if` (which in turn sits in a function
value passed to `for`), but bypasses all of this (unlike most programming
languages with function values). This is essential for functions to be able to
work as proper control structures.

If this feels like it is similar to exception handling in other programming
languages, that's because it is. Lobster even allows you to specify the name of
the function to return from (e.g. `return "expression expected" from parse`),
which is extremely handy when you want to be able to return errors from a bunch
of helper functions without having to pass it back through all intermediate
functions, such as when writing a parser. This is a simple form of exception
handling, that is also powerful enough to allow
you to implement fully general exception handling in Lobster code, see
`exception.lobster`.

You can use the keyword `program` instead of a function name to force returning
from the entire program.

If you need to return from a function value with an explicit return, you need
to turn that particular function into a named function instead.

### Multiple Return Values

return can specify more than one value to be returned, which can then be
received by the multiple assignment syntax introduced above:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def m(): return 1, 2
let a, b = m()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All return statements for any function must all return the same number of return
values.

When `m` returns multiple values, they get assigned to each variable in turn.
If there are more return values than there are variables, additionally
values are thrown away, and if there are more variables than there are return
values, this is an error.

Other than functions (and in assignments statements, see above), expressions
can return multiple values in other contexts too, but there may need to
be placed in parentheses to disambiguate them from other uses of `,`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let x, y = if foo: m() else: (1, 2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### Scope

Functions and variables declared there-in always obey lexical scope: any use of
a variable always refers to the closest enclosing definition of it.

Since functions and function values can be defined at any scope level, this
means they can access variables from enclosing scopes, called *free variables*.
Free variables are essential to make Lobster's higher order functions
convenient. References to free variables are only valid within the lexical scope they
are defined, which luckily is almost always the case, but can be broken by
storing a function value and then calling it at a later time outside of the
context where its free variables were valid, which will result in a runtime
error. Other languages use *closures* to ensure availability in all cases, which
are very costly (parent stackframe(s) may have to be dynamically allocated) as
opposed to Lobster's approach which makes function values and free variables
have no overhead compared to regular functions and variables.

### Explicit Free Variables

You can access free variables outside of their natural scope by declaring them
explicitly, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def foo(a, b) [c, d]:
    c = a
    d = b
def bar():
    var c = 0
    var d = ""
    foo(1, "hello")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Which is pretty much identical to the more familiar:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def bar():
    var c = 0
    var d = ""
    def foo(a, b):
        c = a
        d = b
    foo(1, "hello")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With the only difference that the former is of course more flexible in code structure,
as `foo` can be used from more contexts.
You may refer to both variables and members that are in scope in the call stack context.
You may give these free variable declaration a type, to enforce the type you expect
the free variable to have.
Using these explicit free variables, you can often avoid using global variables
entirely, and it is easy to create functions that can be used used in different
contexts, or have their context overridden.

### Overloading and dynamic dispatch

Overloading and dynamic dispatch are part of the same system, the only difference
being whether choosing the right function is done at compile time or runtime.

You can define these overloads anywhere, either as part of a class, or outside
of them, regardless of whether you wrote the original class. For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def f(a::A): return 1
def f(b::B): return 2
def f(c::C): return 3
def f(i:int): return 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(as we note above, using `::` instead of `:` merely means all fields of that type
become directly available, saving you having to type `a.`, but is otherwise
equivalent.)

What happens when you call `f` depends on the types above, and the type you call
it with. If all 4 types are unrelated, then you guaranteed get static dispatch
(a normal function call). If `B` inherits from `A`, but `C` is unrelated, and you call
with either a `B`, `C` or `int` argument type, you still get static dispatch, since
there is statically only one option.

Only if you call with an `A` argument however, you get dynamic dispatch,
since the argument may point to a `B` value, and `B` has a different function
implementation. A dynamic dispatch goes thru a "virtual table", and while slower than
static dispatch, is still very fast. As you can see, whether something is "virtual" gets
decided per call, and with knowledge of the whole program (all types and functions that
can possibly exist), so typically less calls result in dynamic dispatch than in other
languages.

Types like `int` never participate in dynamic dispatch, since they don't have a
sub-class relation to any other type.

Defining these functions can also be done "in line" in a class declaration, like so:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class A:
    def f(): return 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This definition of `f` for `A` is entirely equivalent to the one above, except
the name of the first argument is now `this` instead of `a` above.

Only the first argument to a function is used to resolve dynamic dispatch, but
for static overloading, all arguments will be taken into consideration.
Lobster used to have the ability to dispatch on all arguments, called "multi-methods",
which at least academically seem very elegant.
In practice however, these are slow (require complicated look-up tables) and ambiguous
(hard to tell which function will get called, sometimes accidentally combine unrelated
functions into a multimethod and get unexpected errors or slow-down). Single dispatch
gives predictable, fast polymorphism that seems to work well for most languages,
so for the moment, multi-methods are removed from the language.

Overloading and dynamic dispatch can even be mixed with type specialization (see
[type system](type_checker.html)), meaning you can generate multiple versions of
a polymorphic call that do different things. Simply leave out the type of any
arguments beyond the first:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class A:
    def g(c): return c + 1
class B : A
    def g(c): return c + 2
x : A = B {}  // Type is A, but dynamic value is a B!
assert x.g("hi") == "hi2"
assert x.g(3) == 5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here, the call to `g` is dynamically dispatched for `A` or `B`, but choosing the
`int` or `string` specialization is entirely static.

You can force calling a superclass method with the `super` keyword:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class B : A
    def f(): return 1 + super f()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That `f()` is statically dispatched to call `A`'s version of `f` (or its
superclass, if it doesn't have one).

You can also "dynamic dispatch" with `switch` ! You can use class names as
switch cases:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
switch x:
    case A: print x.field_in_a
    case B: print x.field_in_b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As you can see, the type of variable switched on will be "upgraded" to the type
matched, so you can access its fields.

switches on types are "exhaustive", meaning if you don't use a `default` case
(and its a good habit to not use those) you will get a compile-time error if
a type is not covered by a switch (all possible subclasses of the type of the
switched on value).

Superclass cases can apply to subclass cases, and if both are present, the
most specific case will always be used. It is a good idea to make superclasses
`abstract` for use with `switch`, that way you may omit a case for them,
causing all their subclasses to need their own case.

The actual implementation use vtables much like the above dynamic dispatch,
so is similar in speed too.

### Functions with different number of arguments / default arguments.

You can define functions with the same name but different number of
arguments. These are essentially treated as independent functions, in the sense
that which is being called is always determined completely statically.

Functions can even have default arguments, as long as the default arguments
don't cause ambiguity with other functions of the same name:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def da(a:X, b, c = x + 1): return c
def da(a:Y, b, c = x + 1): return c
def da(a): return a
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This defines 2 complete separate functions, one that has 3 arguments (and can
be called with 2, since it has one default argument), and one with 1 argument.
As you can see, since there is no overlap in number of arguments, it is always
clear which variant is being called.

The version with 3 arguments has 2 overloads. Overloads must have exactly the
same default arguments, if any.

Default arguments are simple substitution, writing `da(1, 2)` is exactly the same
as writing `da(1, 2, x + 1)`. That's why you can even use variables in these
default arguments, as long as they're in scope when called.


### Operator overloading.

You can overload what operators do on `class` and `struct` types, by writing
a function that defines what the `operator` should do:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct A:
    x:int
    def operator+(o:A): return A { x + o.x }
    def operator-(): return A { -x }

print - A { 2 } + A { 3 }  // A { 1 }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may currently overload: `+` `-` `*` `/` `%` `++` `--` `==` `!=` `<` `>`
`<=` `>=` `&` `|` `^` `~` `<<` `>>` `=` `+=` `-=` `*=` `/=` `%=` `&=` `|=`
`^=` `<<=` `>>=` `[]` (indexing).

Overloaded operators are parsed with the same operator precedence as for the
built-in operators, but when it comes to typechecking, they are handled as
regular function calls, with all that entails. The above expression is thus
handled internally as `operator+(operator-(A { 2 }), A { 3 })` where `operator+`
is just an ordinary function name.

The assignment operators make most sense to overload on `class` types, since
there you can overwrite the members of the `this` (or left) argument of the
operator. There is currently no way to do this with `struct` which are always
copied by value.

See more examples in `modules/quaternion.lobster` and `tests/operators.lobster`.


### Global and Class member variables with function scope.

You may declare a (what appears to be) a local variable with the `member` keyword
instead of `let`, which automatically stores it in the surrounding class:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class Foo:
    a = 1
    def bar():
        member b = 2
        b += a
        return b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Calling `bar` will give different results each time, it really is almost the same
as writing:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class Foo:
    a = 1
    b = 2
    def bar():
        b += a
        return b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The difference is that `b` is not available outside of `bar`, trying to access it
will result in an error.

But why would you want to do this, if it so similar? A small example doesn't do
this justice, but in games it is very common to need a lot of variables that
track state of things that happen across frames, which are often used in just
a single method, and end up cluttering the class they are in. By using `member`,
you put the declaration closer to where it is used, which makes it easier to
view all occurrences in larger classes. It also makes it easy to see that the
variable is used only in a single method. This reduces "cognitive load" in
understanding the code, compared to seeing a long list of member variables at the
top of a class and not knowing what their relationship is. Seeing that the
variable is local to, say, `render()` also gives additional information what
the variable may be used for.

Currently, `member` must occur in a function declaration that is declared
inside a class (not a struct), restrictions that may be lifted in the future.

You can do the same for functions outside of classes with the keyword `static`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let a = 1
def bar():
    static b = 2
    b += a
    return b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Which again is pretty much the same as writing:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let a = 1
var b = 2
def bar():
    b += a
    return b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With again the main difference being that in the former, `b`'s scope is restricted
to `bar`.
This is not as useful as `member` because there is only ever one instance possible,
but still nice to use when you can to simplify the complexity of global scope
elements.

But these two features are just the start of the real fun: the `member_frame` and
`static_frame` keywords. These behave like their counterparts above, with one
subtle difference: they will be reset to their initializer whenever a frame does
NOT use the variable. Or rather, their state is persisted as long as frames
keep using the state. It's like "immediate mode", but for state. For example using
`static_frame` (`member_frame` works the same other than where the variable is stored):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def foo():
    static_frame b = 0
    print b++

gl.window("foo", 100, 100)
while gl.frame():
    static a = 0
    a++
    if a % 4:
        foo()
    else:
        print "/"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This will print an endless sequence of `0 1 2 / 0 1 2 / 0 1 2 / ..` until you
close the window. Why is this special? Notice that `foo` didn't need to be told
when to reset its sequence, that was automatic. In a game, you often have a lot
of systems and states those systems can be in, and when something changes (the
user goes into a menu or a particular gameplay or animation state), all these
systems need to be "updated" to be aware of the new situation. Here, much like
with an immediate mode gui where you don't need to worry about creating and
deleting widgets, simple control flow can dictate what systems are "active",
and their associated state automatically gets reset when the situation changes.
It's as if the variable `b` doesn't exist when `foo` is not being used, and
it automatically gets created/deleted for you.

variables declared this way use more space and an extra check (an extra variable
to check the frame count) but otherwise function just like normal variables,
so you should feel free to use them wherever they make the code simpler/clearer.


### Constructor functions

As shown above, a user defined type always comes with a plain constructor that requires
exactly all initialized fields in `{}`. That is sufficient for most cases but sometimes
you may want to do additional processing on the inputs where the mapping from inputs to
fields in not 1:1.

In that case you can declare a function with the keyword `constructor`
instead of `def`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
constructor Foo(n:int):
    return Foo { map(n): 0, map(n): 1 }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This function behaves like a normal function, except that it marks type `Foo` as having
a constructor, and hence forth doesn't allow code outside of this function to be constructed
using a plain `{}` constructor, it must call this function instead. This is because
a constructor may encode an invariant, such as in this case that the object is always
initialized to two vectors of the same length with elements initialized to 0 and 1 respectively.
You couldn't do this with a plain constructor, since there would be no way to take the
variable `n` into account.

Another common case is wanting to make a variable non-nil, but there is no way to
construct a general instance of the type that would work for all cases. Now you can
make it depend on a caller supplied argument.

You call these constructors with regular function calling syntax (e.g. `Foo(10)`)
instead of with `{}`, to make it clear that additional code may be executed beyond plain field
initialization (and that a function is called).

You may create overloads for constructors much like regular functions, or even make them
dynamically dispatch, as long as they all result in the given type.

Typing
------

Lobster is statically typed, though most of the time you don’t notice, since
most types can be inferred. You specify types:

-   To define overloaded / dynamic dispatched functions (see earlier).

-   To provide coercion (`int` -\> `float`, anything -\> `string`)

-   As documentation.

-   To get simpler/earlier type errors.

As we've seen, you can type function arguments and UDT fields.

For more detail, see the [type system](type_checker.html).

Enums
-----

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum example:
    foo = 1
    bar
    baz
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An `enum` defines a "strongly typed alias" for the `int` type. What this means is
that these values are fully compatible with `int` in any use, but a regular `int`
can't be passed to a context where an enum type is explicitly requested.

You can convert integers explicitly to an enum with a coercion function, e.g.
`example(1)` will create a value equivalent in type and value to `foo`.

If you leave out the `= 1`, the sequence will start
at `0` instead. Values automatically increment from the last explicitly specified value,
so `bar` will be `2` here. Instead of `enum` you can use `enum_flags`, which changes the
default first value to `1` and uses `* 2` to get to next value instead of `+ 1`.

Functions like `string`, `print` will get you the name of an enum value, and likewise
`parse_data` can turn these names into enum values (when part of a data structure).

When you use an enum in a `switch`, it is an error to not test all values of an enum
(if there is no default case).

### Booleans

A bool is not a built-in type, rather it is defined as an `enum` in `stdtype.lobster`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum bool:
    false
    true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because they are enums, they have the same typing rules: a `bool` can be used anywhere
an `int` is expected, but not the other way around. Similarly, you can use e.g. `bool(1)`
to convert ints.

Programs Structure
------------------

A lobster program is like the body of a function: a list of expressions on
separate lines, defined by a single file, the main file of your program. At this
top level of a file, you can additionally use the `import` keyword to bring
additional code into your program:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import std
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The contents of that file will be merged into your main file at the location of
the `import` for the purpose of compilation. If you import the same file twice,
the second occurrence will be ignored.

An identifier like `std` is the same as specifying `"std.lobster"`, similarly `a.b`
is short for `"a/b.lobster"`.

Modules will typically be loaded relative to 2 locations: the current
main `.lobster` file being compiled, and wherever the lobster compiler is installed.
In both those locations, files may be optionally be found under an `modules`
sub-directory.
You can use `import from "path/to/"` to provide additional such starting directories
(relative to the current main `.lobster` file being compiled) that any following import
statements (recursively) can use.

You may use the keyword `private` at the top level in a file to prefix structs,
variables, functions, enums, fields and methods that you don't want to be
visible outside that file.

Memory Management
-----------------

Lobster uses (compile time) reference counting as its form of management for many
reasons. Besides simplicity and space efficiency, reference counting makes a
language more predictable in how much time is spent for a given amount of code,
since memory management cost is spread equally through all code, instead of
causing possibly long pauses like with garbage collection. Lobster has a custom
allocator that is very fast.

Most reference counting happens at compile time using a "lifetime analysis"
algorithm, details [here](memory_management.html).

Reference counting has one problem, which is that it can't deallocate cycles.
For example, this code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class rec:
    r:rec?

var x = nil
x = rec { nil }
x.r = x
x = nil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

will cause a memory leak, since initially the object that `x` points at has a
reference count of 1, then that count increases to 2 because it now points to
itself, and then when the count is reduced to 1 because of `x`'s reference going
away, we now have an object with no outside references that still thinks its
being referenced, thus not deallocated. That is a leak. Now this is a simple
example, but in the general case with complex data structures, it is not
generally possible for a programming language to ensure this never happens.

Leaks like these are not common, as they only occur with graph-like structures
or "parent reference" common in more complicated data structures. An example in
a game might be if two game units refer to each other as their "enemy", and then
both die at the same time with the programmer forgetting to reset the enemy
field before they die.

Lobster deals with this by detecting that such objects are left over at the end
of the program, and alerting the programmer that there are leaks. It then outputs
a "leak report" with all leaks in somewhat readable form (with types and values),
making it easier for the programmer to figure out what caused the leak. The
programmer can then easily fix the leak by setting the reference causing the
cycle to `nil`, like clearing the enemy field when a unit dies, or by writing
`x.r = nil` in the above simplified example.

More details on Lobster's [memory management](memory_management.html).


Control Structures
-----------------

As noted, all of these follow closely the function call syntax introduced above
as much as possible, but are otherwise treated specially by the language.

### if

`if` may be followed by multiple `elif` blocks and a single `else` block:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if a < 0:
    print "negativity not allowed!"
elif a < 10:
    print "single digit!"
elif a < 100:
    print "double digit!"
else:
    print "way too big!"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`elif` is simply short for writing `else: if`. You can also write these on a single
line, which is only recommended when very short, e.g. `if a < 0: 0 else: a`

### for

`for` is the only built-in construct taking 0 to 2 arguments to the block: the element
being iterated over, and iteration index.

We can iterate over vectors (each element), strings (each byte), or integers (values
0..N-1):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for("hello") a, i:
    print "{i}: {a}"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here `a` will contain the 5 characters and `i` will be just `0` to `4`.

The module `std` contains further useful loop constructs on top of `for`, like
`map`, `filter`, and `exists` etc.

### while

`while` is an odd function, since it is an exception to the rule of Lobster
syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
while a < 10: a++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That looks perfectly normal, but one thing should stand out: while takes not
one, but 2 function values. Normally, in Lobster, this would make more sense:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
while():
    a < 10
do:
    a++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

but since people are so used to the way while loops work from other languages,
the first argument has a special type that automatically converts an expression
into a function value. When you think about it, even in languages like C the
condition of a while is the only part of the language that can be executed more
than once yet does not use / cannot use the block `{}` syntax. This exception is
carried over in Lobster. This is not great for readability so isn't generally
used elsewhere.

`while` returns void. A similar function int module `std` called `collectwhile`
returns a vector of all body return values.

### break

Both `for` and `while` can have a break statement inside of them, that
exits the enclosing loop. Alternatively, use `return` or `return from` (see
above) for more complex cases.

### continue

Both `for` and `while` can have a continue statement inside of them, that
interrupts the current loop iteration.

### User defined control structures

Many other functions that look like regular functions are actually also control
structures, like many of the graphics function that change the current rendering
state. An example is `gl.translate`, that optionally takes a body, and will
run the body and restore the previous transform afterwards.

### switch

`switch` has special syntax, since it does a lot of things different:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var st = switch i:
        case 1: "no"
        case 2, 3:
            var x = i
            "yes{x}"
        case 4..6, 8: "maybe"
        default: "what?"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The value you switch on may be int, enum, float, string or class instance. Cases may test for multiple
values, even ranges (which are inclusive). When testing for class instances, the cases are
types which must exhaustively cover all non-abstract sub-classes of the class type.
Enums are also required to be tested exhaustively. An enum value that doesn't correspond
to a value in the current enum definition (such as one read from a file) will produce a runtime
error if the switch does not have a default case.

### guard

`guard` is a special variant of `if` for writing code in "early-out" style:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
guard a >= 0:
    print "error: a is negative!"
imagine_10_lines_of_code_processing_a_here()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Is equivalent to:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if a >= 0:
    imagine_10_lines_of_code_processing_a_here()
else:
    print "error: a is negative!"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Why would you want this over a traditional if-else? The idea that code becomes
easier to read if it is written in a more linear style, dealing with all cases
where the code does not apply first, before getting to the main body of code.
This becomes more obvious if you use nested if-thens.

A lot of code tends to use a `return` inside an `if` for this early-out style of
programming, but that has the problem that it only works at the top level of
a function. `guard` works for code anywhere, and does not require the extra
`return` statement.

If there is no code to run in the error/exceptional case, you may even shorten
it to:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
guard a >= 0
imagine_10_lines_of_code_processing_a_here()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Is equivalent to:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if a >= 0:
    imagine_10_lines_of_code_processing_a_here()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That reads like an `assert` except instead of aborting the program, it skips the
rest of the block.

### assert

`assert` simply passes thru any expression, excepts halts the program with an error
if the value is `nil` (or `0` / `0.0` / `false`):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let a = assert b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`a` will always be assigned a non-nil value, or execution will never get there.
`assert` also changes the type of value `b` from nillable to non-nillable for the
current scope, so you can use it in contexts that require a non-nil value.

### Conditional declaration

Some control structures that start with a condition (`if`, `guard` and `assert`)
may have `let` or `var` declarations inside of them. The variables will
be assigned, then tested, and are only available inside the scope of the construct.
As before, the type of the variable will always be non-nil.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if let a = maybe_nil():
    // Here a is never nil.
// Here a is not in scope.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Which is similar to, but better than:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let a = maybe_nil()
if a:
    // Here a is never nil.
// Here a is still in scope!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To do this with multiple variables, just use `and`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if let a = maybe_nil() and let b = also_maybe_nil():
    // Here a and b are never nil.
// Here a and b are not in scope.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Modules and Name Spaces
----------------------
A module is simply a single `.lobster` file, that can be imported into another using the
`import` keyword. You can `import` a module from multiple files and it will only be compiled
once.

You can prefix any top-level declaration by `private` to cause it not be available to
users of the module.

Lobster has a namespacing mechanism that uses `.` for separating namespaces:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
namespace foo

class bar:
    x = 1

def baz(): return bar {}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Names `bar` and `baz` can be used as-is inside this module, but must be referred
to as `foo.bar` and `foo.baz` outside of this module. Non-top level items like `x` are not
affected.

Most built-in functions come with a namespace, such as `gl` etc.

Since namespaces look the same as object dereferencing, it is recommended to use
a name with a leading uppercase for namespaces wherever possible.


Declaration order
-----------------
Lobster is a language that relies heavily on type inference and generic types, and generally
not requiring you to specify types, the order in which things get type-checked sometimes
matters.

Lobster type-checks function calls in call order, but type declaration in the order in which
they are specified in the source code, or imported.

As such, to allow the maximum amount of freedom it what can refer to what, it is recommended
to import files and declare types (structs and classes) as much as possible in the order of
dependencies (least dependent things first), and call functions from top level (which triggers
a lot of use of these types) only after all have been declared.

This is not always possible, so there are ways to declare things ahead of definition, for
example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class Monster
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(note the lack of `:` introducing the definition) pre-declares this type, so it can
be referred to by types defined before `Monster` is finally defined. This allows for
circular dependencies.

Similarly, you may declare variables before you define them:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class World
var world:World

// Lots of types that may want to access `world` as a global in their methods goes here.
// Then finally `World` gets defined based on the earlier types.

var world:World = World {}
world.init()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is an error to access `world` by code in between its declaration and definition.
Typically, all code accessing `world` in any methods in between only gets called
below, so this works out fine.


Type Checking
-------------

This has its own document, [here](type_checker.html).


Built-in Functions
------------------

Please refer to the [built-in function reference](builtin_functions_reference.html).


String Interpolation
-------------------
This is a convenience feature that allows you to write arguments to string
conversion inline in the string, instead of endless amounts of `" + "`
separators, which tends to be less readable for longer sequences.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"a = {a} and b = {b}"  // Same as: "a = " + a + " and b = " + b
"a = {f(a) + 1}"       // Same as: "a = " + (f(a) + 1)
"{a}"                  // Same as: string(a)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because of this feature, if you actually want to put `{` or `}` in a string
constant, they must be escaped (by using 2 of them, or prefixing with a `\`),
e.g.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let a = 42
print "\{ {a} \}"  // Prints: "{ 42 }"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Multi-threading
---------------

Lobster has built-in multi-threading functionality, that is in its early stages.

It is different from multi-threading in most other languages, in that it does not
allow threads to share memory or any other VM state. It essentially runs one Lobster
VM per hardware thread / core, each running an independent and isolated copy of
your Lobster program. This prevents entire classes of potential concurrency bugs,
like race conditions.

Communication/synchronisation between the threads is explicit through the use of a
"tuple space" (a bag of Lobster objects used as messages) which are copied rather
than shared. While copying is potentially slower than sharing, it allows each
Lobster VM to run as-if it was single-threaded, with no synchronisation primitives
to slow it down (for example, memory allocators in Lobster are single-threaded),
no GIL (global interpreter lock) or other multi-threading overhead, so overall
performance can easily be higher than shared memory concurrency systems.

The use of tuple spaces and 1 VM per thread suits "worker" style concurrency, for
example if you have 100 parallel tasks to perform, you throw each of those in
the tuple space, and the individual VMs grab and complete them, given automatic
load balancing for however many cores are available.

For now, the easiest way to get a feel for how this works is to read
`samples/threads.lobster`.
</contents>
<source>
/tmp/tmpo9l8mwkb/lsp.md
</source>
<contents>
---
title: Lobster LSP (Language Server Protocol)
---

Implementation
-------------------
The lobster LSP is written in typescript, and runs with node.
It calls internally the lobster compiler for the features.
> LSP simply uses [command line arguments](command_line_usage.html) from the lobster runtime.

I want to use this for x editor/IDE
--------------------------------------
Usually you have to package this LSP in a addon for your preferred IDE.
See your IDE/editors documentation on how to integrate this. 
PRs are always welcome.

You compile the LSP to a final js file to be execute by node with `npm run webpack`.
</contents>
<source>
/tmp/tmpo9l8mwkb/memory_management.md
</source>
<contents>
---
title: Memory Management in Lobster
---

This is a more in-depth explanation of how memory management in Lobster works, and
is typically not needed to be understood fully to use the language.

It may be interesting to those wanting to implement a similar scheme in another language.

Introduction
------------
Memory management is an aspect of a language that has one of the biggest influences
on how a language turns out: it affects the type system and the kinds of types you can
have, it affects efficiency in both time and space, it affects the cognitive model of
the programmer in what data structures can be represented, it affects latency, interoperability,
and much more.

Yet, it is often ignored and almost invisible at the same time. Many consider it to be
a "solved" problem with probably 95% of programming languages out there using some
form of garbage collection: allocate, then worry about reclaiming unreachable objects
later.

I think it is far from solved. If I'd have to make a top-10 of "least elegant
algorithms in computer science", the #1 would be an easy pick. The idea that just
because "who is pointing to this object" is a hard question we are not going to
even try to track it, and instead repeatedly scan large parts of the heap to recover
that information later, really makes me cringe.

The problem is maybe that for the longest time, the alternatives have not been great.
Low level languages would use manual memory management (efficient but error prone),
and some have used reference counting. Then there were languages based on linear
types or regions, but those never entered the mainstream.

I've personally always thought of reference counting as the "least bad" solution,
which is why it was initially used for Lobster. Many people dismiss it out-right
because it can't collect cycles, but I've found that, in practical use, getting a
"cycle report" at program exit that helps the programmer know where to break those
cycles, is largely sufficient.

I mentioned linearity (every object can only have one pointer to it) and regions
(every object is assigned a memory pool that outlives them all), and I have implemented
languages in the past that implemented both of those strategies. While viable, I felt
at the time they required too much programmer assistance to be mainstream.

Ownership models
---------------
There is a memory management design space which I'll collectively call "Ownership"
which is a generalization of the linearity models: one pointer always owns an
object (and is responsible for its deallocation), and others merely "borrow" it.

This now poses new questions: How do we determine who is the owner? When is
borrowing allowed? How do we detect a borrower that outlives an owner? What
about an owner being modified while there are borrowers? Do we check any
of these at compile time, runtime, or a mix?

There have been many ownership models in the past, but only recently they are
becoming more mainstream:

* Rust is the poster child, which tries to solve all of the above questions at
  compile time, at the cost of much programmer assistance.
* Modern C++ with `std::unique_ptr` is essentially an ownership model, except one
  that answers questions like "How do we detect that a borrower outlives an
  owner" with "We don't". But even with such caveats, it largely works well,
  and is a huge improvement over the manual memory management of C and even
  the manual RAII of earlier C++.
* Swift, one of the few languages that uses reference counting (inherited from
  objective C) has intentions to (optionally) move to
  [ownership](https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md).
* Nim has intention to move away from GC to ownership (see post
  [1](https://nim-lang.org/araq/destructors.html),
  [2](https://nim-lang.org/araq/ownedrefs.html)) with a model that is partially
  programmer assisted and partially runtime.
* D has [plans](https://dlang.org/blog/2019/07/15/ownership-and-borrowing-in-d/).
* Many more research-y or less known languages, e.g.
  [Gel](https://pdfs.semanticscholar.org/d0f2/d28962d2a50d1914f0af8243d3f382fe077c.pdf),
  [Dyon](https://github.com/PistonDevelopers/dyon/issues/173),
  [CoSy](http://liu.diva-portal.org/smash/get/diva2:20899/FULLTEXT01.pdf),
  [ParaSail](https://drive.google.com/file/d/0B6Vq5QaY4U7ubm5qVkFpMEtmN2s/view),
  [Cone](http://cone.jondgoodwin.com/memory.html),
  [Scopes](https://gist.github.com/paniq/71251083aa52c1577f2d1b22be0ac6e1),
  [Pure RC GC](https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf),
  [Mitten](https://github.com/doctorn/micro-mitten).

I personally think this general direction is the future of memory management.
It just needs to be made more friendly than Rust for most programmers to
want to come on board. Lobster offers a possible direction.

Lobster's Memory Management Strategy
-----------------------------------
This has two parts, its by-value model and ownership analysis.

### In-line, by-value structs

The best memory management is.. not to have to manage it at all!
You can make an incredibly fast memory manager, but it will never beat simply
having less objects to manage. This is the thinking behind Lobster's
by-value structs, which offer similar "zero abstraction cost" objects
to ones available in C/C++, Rust, and even C#, but surprisingly not
in most other languages. It is the most effective and cheapest way towards
more efficient memory use that frankly every language should have.

Essentially, you declare an object with the `struct` keyword instead of the
usual `class`, which causes Lobster to always allocate this object inline
in the parent, where "parent" can be another struct or class, a vector, or
simply the stack (as a local variable). On an implementation level, it is
as if you added all the fields of the struct as fields/variables to the
parent, so writing `s.x` (where `s` is a struct) is just as cheap as
writing `x`. The struct disappears.

This of course has limitations, in that you're completely dependent on
the lifetime of the parent, and that you assign these kinds of struct by
copy, rather than by pointer. That means it is not great for large
objects, but usually up to 4 fields or so this is still more efficient
than heap allocation.

Currently, such structs are immutable, since that simply makes sense for
small, copied objects. This is likely to be relaxed in the future to also
allow mutation.

There are situations where rather than copying the implementation could
use a short-lived reference instead, like is common in C++. This is
however not actually faster in many cases, and more importantly, a
reference would be subject to the ownership analysis below. By making
them copies, we essentially "reduce pressure" on that algorithm, meaning
it is more likely to produce optimal ownership assignments and less
errors.

Having these by-value structs is especially important in a language like
Lobster that has so far focussed on the areas of games and computer
graphics, which make intensive use of 2D/3D vectors. Having such types
be as cheap as possible is important.

### Ownership Analysis

Lobster combines its original (runtime) reference counting with a ownership
analysis algorithm, to get "compile time reference counting".

This is a fully automatic algorithm that mostly does not require programmer
intervention. In my personal testing, working with several dozens of Lobster
programs (many of which medium sized game prototypes) I needed to make minor
changes in only 2 locations when transitioning from runtime to compile-time
reference counting, the rest "just worked". Or rather, I was able to make
the algorithm jump through hoops such that code changes weren't necessary.

Essentially, the algorithm picks a single owner for each new heap allocation,
which is usually the first variable, field, or vector element it gets
assigned to, and then tries as best as possible to make all uses from there
on "borrows". The initial ownership and all borrows do not require any
runtime reference counting. If somewhere else in the code something wants to
own that same value, it will insert a reference count increase only for this
particular use (in Rust, this would cause an error instead). Using this
analysis was able to remove around 95% of runtime reference count operations.

This is the default behavior, since it is "good enough" of an optimisation
for most code, and very convenient for the programmer. For those cases where
the programmer wants maximum control however, they can opt-in to a more Rust-like
model on a per variable basis, which will guarantee there will only be one
owner ever, and error out if the analysis is not able to guarantee this. This
will also be able to remove the reference count field from objects entirely,
a further optimisation. This has not been implemented at the time of writing,
however.

### Errors

These are errors that may happen as a consequence of ownership analysis, though
all of them have proven to be very rare.

~~~~
cannot assign to x while borrowed
~~~~

This can be caused by code like:

~~~~
var x = "hello"
def f(y):
    x = "world"
    print y
f(x)
~~~~

Here, `y` borrows `x`, then `f` tries to overwrite `x` while still being borrowed,
which would cause it to deallocate `"hello"` while `y` is still pointing at it.
It is pretty rare for code that uses a borrowed value to be accessing the original
value also. As I mentioned, this only happened twice in a large volume of test code,
and is easy to avoid.

~~~~
cannot assign to borrowed argument: x
~~~~

This typically never triggers, as arguments that are assigned to are typically forced to
be owners, but there are currently some exceptions related to dynamic dispatch where this may still
happen. Likely will be eliminated entirely in the future.

~~~~
variable x still has 1 borrowers

x used in <feature> without being borrowed
~~~~

These two I've never even seen happen, they largely exist because I am not smart enough
to write a formal proof that they can't happen, and then ensure that my code matches the
proof :)

The algorithm in detail
----------------------

The "ground truth" for how the algorithm is to be found in `typecheck.h`,
this section is merely a description of it. If you were hoping for pages of
equations like the typical PL paper, I am going to have to disappoint.

More on the type checker [here](type_checker.html).

Wait, what, the type checker? Yes, as much as I would have preferred to make
the ownership analysis a standalone algorithm, it is interwoven with type checking.
The reason for this is that a lot of the power of Lobster centers around its
"Flow Sensitive Type Specialization", meaning it type checks functions in
call-graph order, and specializes them based on types. As it turns out, to
most optimally remove reference count operations, *we want to specialize on
ownership as well*. Making it a separate algorithm would mean duplicating a lot
of this logic, so I decided to interleave them.

### AST ownership matching

The ownership analysis works differently from most other languages in that rather
than working just on variables and other storage locations, it works on all
values in the language.

To be more precise, every AST node has a ownership "kind" it expects of its children,
and an ownership kind it passes to its parent. The core of the algorithm is thus the
matching that takes place between child and parent:

* When the two agree, nothing happens. This is most of the time. For example in
  `let a = [ 1, 2, 3 ]` the vector wants to be owned, and the variable wants to own,
  everybody is happy. No Reference counts touched.
* When the parent wants to own, but the child wants to borrow, then either a
  a reference count increase has to be inserted (by default), or it is an error (optionally).
  For example, in `let a = b`, `b` wants to borrow (lend) itself, but `a` wants to own,
  so this has to be reconciled.
* When a parent wants to borrow, but a child wants to be owned, we insert an anonymous
  variable in the current scope that will delete the value later, much like what happens
  to R-values in C++. For example in `print [ 1, 2, 3 ]` like most built-in functions
  `print` defaults to only wanting to borrow the value, and the vector wants to be owned.
  So instead it gets held on to and deleted at the end of the scope.

### L-value borrowing

Owned values are simple.. these are values that someone needs to be responsible for
at all times.

Borrowed values are a little more complicated. Whenever an expression returns the
value of a variable, field or vector element we want to default to borrowing these
values, since the L-value already owns it. We have a stack of currently active L-values,
and the ownership kind returned by the expression refers to these stack elements. These
stack values are also reference counted, as multiple borrows may be active at once.
This reference count decreases as borrowed values get "consumed". Mutating a
borrowed L-value with a reference count > 0 produces the above error. The
reference count not being 0 at the end is a bug in the ownership analysis :)

Note that variables currently always own. This was done for simplicity, as in
theory a variable could be made to either own or borrow depending on the needs
of its initial RHS, but this was awkward in cases where the definition and
subsequent assignments disagreed, and generally made ownership analysis more
difficult. This could be revisited in the future once the consequences of
the algorithm are better understood, or maybe when more accurate dataflow
information is present.

The end of a variable's lifetime is typically the end of the scope, though
making it its "last use" is being worked on, see `return` below.

### Function specialization by ownership.

Function ownership specialization is probably quite unique to Lobster, and solves an
important problem: if different callers to a function have different ownership kinds
that would be ideal for their arguments, the compiler (or worse, the programmer)
would have to pick one, and let the others be suboptimal. Not only does this
produce unnecessary reference counting, it reduces the amount of code that
could otherwise work error-free in the context of strict ownership. For example:

~~~~
def f(x): print x
f([ 1, 2, 3 ])
f(a)
~~~~

If `x` had been fixed to own because of the first call, the second call
would have been less efficient, or even an error. Now they both get to be
maximally efficient because of specialization. Now in this simple example
it is easy to see that `x` should really borrow, but it isn't always that
trivial, and would need a more complex ownership analysis that employs
"logical variables" much like type inference currently does (assuming
you want to do this without help of the programmer).

There are currently some exceptions to this:

* Arguments that are assigned to are always owned.
* The return value of a function is currently always owned.

Much like variables, some of these could be relaxed/improved in the future.

### Ownership kinds for AST types

These are currently how the different AST types interact lifetime wise
with their children (wants) and parent (results).

Note that most of code also uses a ownership kind of "any", which means either
that the ownership doesn't matter (for e.g. scalars) or that the recipient
is cool with any kind of ownership.

* Assignment wants to own, and results in borrow.
* `if` results in the union of the ownership kinds of both branches. The union
  is simple if both are equal or either side doesn't care. If they differ,
  it defaults to own. It has specialized code to detect if one of the
  branches never returns (has a return statement in it that escapes the
  `if`) in which the ownership kind is that of the other branch.
  The condition wants to borrow. `if` with one branch
  of course does not result in anything.
* `switch` is similar to `if`, but currently always defaults to owning the
  value returned by the cases, since doing a correct ownership kind union
  between many cases in the context of branches not returning is harder.
  This should be improved.
* `and` and `or` are again similar to `if`, but have some special cases
  because sometimes a value is guaranteed ignored (`a and b or c` never
  results in `a`) or values are coerced to `bool` when they are
  incompatible (`"a" or "b"` results in a string that wants to be owned,
  but `[ 1 ] or "hello"` results in a `bool` with the values immediately
  deleted).
* `while` borrows its condition and doesn't care about the body.
* `for` borrows what it iterates over and doesn't care about its body.
  It produces an element variable that wants to be owned.
  Note: this may change in the future to also allow borrowing.
* String constants conceptually result in an owned value (they are a heap
  object), but currently they actually result in a borrow. This is
  because strings are most frequently passed to contexts that would prefer
  to borrow (like `+` or many builtin functions) and thus produce a lot
  of reference count churn. To avoid this, the VM allocates strings on
  first use, but never lets the reference count drop to 0, meaning they
  can safely be borrowed, and reduce total reference counting.
  Or more simply: it's as if there exists an anonymous global variable
  for each string constant that's actually used, and which you borrow
  from.
* `+` on strings wants to borrow, and returns owned. This is the same
  in principle for all binary operators, but thanks to "inline structs"
  this doesn't matter for most of them anymore.
* Built-in functions by default want to borrow all their args, and
  return an owned value. There are exceptions to this rule, which can
  be marked when declaring a built-in, mainly for functions that
  directly operate on a vector or other data structure. For example `push`
  wants to own its second argument, and `top` returns a borrowed value.
* As noted above, `return` typically wants to own what it is returning,
  but currently makes an exception for the frequent case of returning
  a single variable, where it pretends to borrow it. This is because
  otherwise it would typically cause a reference count increase followed
  by a decrease as the variable goes out of scope.
  Extending the cases where this happens, and also generally allowing the
  last use of a variable to be owned by its last use rather than waiting
  for the end of the scope, is planned as a future improvement.
* Any data structure constructors (objects, vectors) of course
  result in own.
* Any L-value results in borrow.

</contents>
<source>
/tmp/tmpo9l8mwkb/mmd_header.txt
</source>
<contents>
CSS: github.css
</contents>
<source>
/tmp/tmpo9l8mwkb/notepadpp_ide.md
</source>
<contents>
---
title: Notepad++ as Lobster IDE
---

Running Lobster programs from within the editor
-----------------------------------------------

-   Install [Notepad++](<http://notepad-plus-plus.org/>) (default install) and
    the NppExec plugin
    ([download](<http://sourceforge.net/projects/npp-plugins/files/NppExec/>),
    unzip the .dll and other files into the plugins folder of where you
    installed Notepad++).

-   Open menu Plugins -\> NppExec -\> Execute and enter:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    NPP_SAVE
    cmd /C C:\path_to_lobster_goes_here\bin\lobster.exe "$(FULL_CURRENT_PATH)"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   Save script under name "`lobster`"

-   Load some lobster code. pressing `F6` and then "ok" should run it. Next time
    press `Ctrl+F6` to bypass the dialog.

-   NOTE: running from within Notepad++ doesn't work for programs that do
    console input thru e.g. `get_line()`. Output (thru `print()`) does work, but
    is sometimes delayed. Graphical programs work well.

Editing
-------

By default, Notepad++ comes set up insert tabs into your code, which is against
the Lobster [style guide](<style_guide.html>), and can result in errors if you
modify the existing examples. In Settings -\> Preferences -\> Language Menu /
Tab Settings you can change this.

Error Highlighting
------------------

-   in Plugins -\> NppExec -\> Console Output Filters, add these on individual
    lines:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    %FILE%(%LINE%): error:*
    %FILE%(%LINE%): VM error:*
    in block -> %FILE%(%LINE%)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   make sure to checkmark them to on, and check bold, or change the color to
    red (`FF 00 00`) or something.

-   This will highlight errors you get from Lobster, and allow you to double
    click on them to go directly to the line of the error. The first one is for
    compile errors, the second for runtime errors, and the third for the
    stacktrace part of runtime errors.

Syntax Highlighting
-------------------

-   NOTE: this file currently only seems to work with a dark background theme,
    so be sure to choose in menu Settings -\> Style Configurator under "Select
    Theme" something like Zenburn first.

-   Language -\> Define your language.., then Import... and choose the
    `docs/notepad++/notepadpp_udl_lobster.xml` file.

-   Save As... "`lobster`"

-   It should now show `.lobster` files with correct highlighting, or you can
    set it explicitly from the Language menu.

Optionally
----------

-   in Plugins -\> NppExec -\> Advanced Options, you can add the lobster script
    as a menu item, or toolbar button, or special hotkey.
</contents>
<source>
/tmp/tmpo9l8mwkb/philosophy.md
</source>
<contents>
---
title: "Lobster Design Philosophy, History, and Future"
---

This document tries to clarify why certain design choices were made in the
Lobster language and system.

NOTE: this may be a little out of date. Lobster has evolved a lot since I
wrote this.

### Primary Motivation

The most important over-arching reason behind everything in Lobster was to make
it a pleasant language to use for one single person: me, the author. I've
designed a fair number of languages in the past that had a particular goal or
should appeal to a particular target group, or were even commercial. Lobster is
not such a language.

Unlike past work, its goal from the start wasn't to try to appeal to anyone in
particular. If you happen to like Lobster, then congratulations, your taste in
programming is probably similar to mine.

Besides being useful to me, creating Lobster in itself was merely meant to be a
fun project. I love creating programming languages, but there's really no money
in it, and generally to most people new programming languages are not desirable
things, which is what had stopped me for a while creating any more of them.
Lobster was the "screw it, I am making one because it's fun" project. That, and
I had some new ideas about some subtle features that would make a language
suitable for my style of programming (heavily refactoring-based).

### What Lobster is not:

-   A popular / mainstream language. For that, I've made far too many peculiar
    choices already, in particular in relation to its syntax (very terse, not C
    based) and its semantics (more functional than OO).

-   A beginner friendly system.

    -   The language: to use Lobster where it shines, you need to get very
        familiar with higher order functions for example.

    -   Its engine, while friendly for simple drawing, generally gives you a lot
        of control (immediate mode rendering), and requires you to understand
        the rendering pipeline more so than simple retained mode object systems
        (e.g. Flash). If you create more complex games with it, be prepared to
        program your own "scenegraph" on top of Lobster's low level drawing
        primitives.

    -   It contains no game editor or friendly IDE. Everything is code.

-   A language for large scale / team programming. Its type system favors
    expressive power over building interfaces. It's best used for small to
    medium sized projects by programmers that know what they're doing.

-   A language that is all things to all people. While I would claim that
    Lobster is a *general purpose programming language*, it is strongly biased
    toward game programming and related fields. With a different set of built-in
    functions I am sure it would make a kick-ass server language, but I don't
    feel it is important to serve every niche.

### What Lobster is:

-   A language design motivated by *refactoring* and *compositionality*. It
    should be easier than in most languages to rip arbitrary pieces of code out
    and reorganize them and make them reusable, to keep the program
    *non-redundant*. Lobster's free variables ensure that your code keeps doing
    what it did before it was moved without needing to create tons of function
    arguments. They allow your new functionality to be as local as possible, and
    look just as terse as any built-in abstractions when using function value
    arguments. I am fanatic about well-factored code, so the design reflects my
    thinking on how give the programmer maximum refactoring fluidity.

-   A language that has some goodies built-in that streamline code typical in
    games, for example almost everything can operate on vectors of numbers
    (2D, 3D, 4D).

-   A language inspired more by functional programming than by object oriented
    programming. Lobster is of course an imperative language first: games are
    full of global state, and I believe that the most natural way to express
    that is directly, rather than indirectly by emulating state (such as with
    monads). That said, any program benefits from trying to write as much code
    as possible in a purely functional style, i.e. if it is easy to express
    something in terms of re-generating data instead of modifying it in place,
    you almost always should. Lobster has some very strong tools to make this
    possible, with a very terse and uniform higher order function call syntax,
    and optionally immutable objects.
    Lobster actually has very powerful object oriented features (its overloading
    and dynamic dispatch being more expressive than in most OO
    languages), but it doesn't push its OO angle to the forefront, and unlike
    OO languages doesn't have an object heavy API. While OO brought us many
    important ideas in programming, it is also single-handedly responsible for
    the crippling over-engineering culture so prevalent nowadays, and Lobster is
    trying to go the opposite direction.

-   A type system that tries to get as close to the experience of using a
    dynamically typed language as possible while allowing maximum efficiency.

-   A language that tries to be very efficient with memory, thanks to
    compile time reference counting, inline structs, and a very fast allocator.

-   The belief that the ideal programming language is... TWO programming
    languages. Any larger project consists of a lot of high level and glue code
    that is infrequently executed and benefits from the simple and terse
    notation of a language like Lobster. However, any non trivial project
    (especially in games) also contains a few algorithms where complete control
    of memory layout and native code is desirable, and for that, there really is
    only one viable language, namely C++. Having access to both languages in a
    single project gives the most options for creating a fast, high quality
    result in reasonable time. Importantly, past systems/engines have not
    realized this potential because they make C++ the dominant language that is
    responsible for all the glue code, thus reducing the utility of the
    scripting language and complicating the overall project. Lobster instead
    wants Lobster code to be the main program, and relegate C++ to implement
    small libraries of speed sensitive code.

-   An engine that adheres to *make simple things simple, and complex things
    possible*. It requires very little code to start drawing, yet the system
    doesn't make any assumptions about what kind of thing you might want to
    program, and how you want to structure it.

-   A portable, cross platform system, targeting desktop and mobile OSes alike.

-   An implementation that cares about simplicity, speed, and robustness.

### What Lobster was (History):

Lobster development started in October of 2010.

Unlike code, normally a programming language design is so intricate, you benefit
from designing almost all of it up-front, before you write the first line of
code. Lobster wasn't designed like that, its design was constantly refactored
much like its implementation. In fact, normally the first thing I write before
I start writing a parser is the grammar, but Lobster's grammar was instead
derived from the parser code. Because initially it was simply a platform for fun
and experimentation of language features, it started out very different, both in
syntax and semantics.

Lobster started out fully dynamically scoped. I like the idea of dynamic
scoping, and wanted to experiment with it, to see if all the people on the net
claiming it is evil are a bunch of whiners. I found out very quickly they are
not whiners and reverted to default lexical scoping.

My other early experiment was a complete implementation of Icon-style
backtracking. For example, you could write things like:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
print #3 < 2 | #3 * 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

which would print `0 1 0 2 4`. In short, whereas in most programming language an
expression returns exactly 1 result, in Icon an EarlyLobster it would 0..N
results. `#` was an iteration operator that would generate values much like
`for` does nowadays, and `|` would simply concatenate streams of values. The
concept of something being false just meant no values were generated, i.e. the
`<` operator returns 0 or 1 results (the lhs). This backtracking would even work
across function definitions.

If that sounds complicated, it is certainly hard to get right, though it was
helped by the fantastic paper *The Implementation of Generators and
Goal-Directed-Evaluation in Icon* by Janalee O'Bagy whose implementation
technique I followed closely.

Sadly, though examples like the above look super terse and very powerful, more
general examples turned out less readable, less general, and not much shorter
than the equivalent code using higher order functions, which is when I got
inspired to instead focus on making higher order functions terser and more
similar to built-iteration, and make sure they have the same shortcutting power
as backtracking (using Lobster's cross-function `return`). I ripped out all
backtracking code at this point. I still have a copy of the last version that
has this functionality in, which at some point I can release if there's
interest.

Syntax wise, EarlyLobster had a more haskell-y / smalltalk-y bracketed syntax.
See for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
factorial: [ n => 1 > n | (factorial n - 1) * n ]
print "factorial of 7: " + (factorial 7)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Function blocks were `[]`, and lists were `{}`. One of the first changes I made
post EarlyLobster was to switch those two, and make function calls more C-style,
as I had to admit I found I liked that better anyway, and made it easier to have
function blocks follow the function call instead of being inside of it. Then I
noticed I could denote function blocks entirely without brackets and just with
indentation, and those were removed too.

The implementation still had the C-stack based function calling implied by the
abovementioned paper, which now wasn't necessary anymore, and Lobster switched
to a more traditional VM stack.

Later, multi-methods, and more recently, coroutines, got added.

Most recently, Lobster transitioned from being a dynamically typed language to a
statically typed language. I prefer programming using dynamic typing, but I had
an idea how I could use specialization in combination with type inference and
flow-sensitive typing to get very far in being able to type-check all existing
Lobster code without having to litter it with types. That challenge took it much
further than I anticipated. The end result is impressively powerful, even though
I made it a bit more strict than I planned (i.e. making `nil` its own type).
More here: [type system](type_checker.html).

Another big change is moving to compile-time reference counts (lifetime
analysis) and in-line structs, about which you can read more in
[memory management](memory_management.html).

This signals the move of Lobster to a more efficiency/strong typing oriented language.
Strongly typed enums and bools got added, and multi-methods got replaced by a very
flexible overloading / dispatching system.
See the [language reference](language_reference.html).

In July 2020, co-routines were removed, along with the lesser known "frame log"
feature. A full explanation of why is
[here](https://github.com/aardappel/lobster/issues/100)
The summary: it is a feature that seems very attractive for game programming,
but in practice never got used (and in most cases works just as well with
classes), and they put a big complexity strain on the implementation that
makes it harder to make the language faster.
The last version of the language that does contain co-routines is marked
with the label `last_coroutine` in git, and the diff showing exactly what
was all removed (and thus gives a good picture on how it used to work) is
[here](https://github.com/aardappel/lobster/commit/9483b7026419fdce5421d22b2181e77e666daf82).
Similarly, the last version that has frame log functionality is `last_frame_log`
and the diff is
[here](https://github.com/aardappel/lobster/commit/274f76ca1f36742469090befbdb7d7eaa108af8f)

### What Lobster will be (Future Plans)

I've collected many random scribbles about what I think Lobster still needs in
`dev/TODO.txt`.
</contents>
<source>
/tmp/tmpo9l8mwkb/shooter_tutorial.md
</source>
<contents>
---
title: "Learn Lobster: Let's create a 2D shooter!"
---

Let's walk through all the steps required to make a simple game in Lobster by
making a shooter in the same vein as "Geometry Wars": enemies come at you from
all directions, and you have to keep shooting them until you invariably... die.
Sound like fun?

You can follow along just looking at the code and screenshots below, or by
loading up `samples/shooter_tutorial/tut*.lobster` and trying them out yourself.

Decent experience in at least one other programming language required. Minor
familiarity with Lobster is required (this tutorial won't explain all the
basics, and focuses mostly on the graphics aspect). No need to know how games
work, though minor math knowledge may help.

### 1: Graphics Setup

Let's start by creating a blank canvas for us to draw on. Something like this:

![](<screenshots/shooter/tut1.jpg>)

Impressively... empty.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import vec
import color
import gl

fatal(gl.window("Shooter Tutorial", 640, 480))

while gl.frame() and gl.button("escape") != 1:
    gl.clear(color_black)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`gl.window` is our graphics initialization routine, and is the first thing we
need to do before we can access any other graphics functionality. We specify a
title and a size, though note that these are merely suggestions: on desktop
platforms the user may resize/maximize our window, and on mobile platforms they
just determine landscape vs portrait orientation, whereas the resolution is
determined by the device itself.

`gl.window` returns an error string if something goes wrong (and things can go
wrong, behind the scenes this call boots up an OpenGL engine including compiling
shaders and what not), and `fatal` is a utility function defined in
`std.lobster` that we're including that will quit the program and show the error
string if available.

Once we're up and running, this while loop is our *frame loop*. Games work by
rendering the current state of the game repeatedly to the screen, preferably
fast (30-60 times per second), giving the impression of smooth animation.
`gl.frame` is the core of all of this: it makes sure we advance to rendering the
next frame, and checks for input etc. If the user clicks the close button or
otherwise terminates the app, `gl.frame` will return `false`, which is our
signal to quit the game. Additionally, we want the user to be able to quit if
they press the escape key, so we check for that too.

Then inside the frame loop, we clear the screen (remember that we draw
repeatedly), and then we're ready to draw. `color_black` is a constant
from `color.lobster`, representing a 4 component RGBA.

### 2: Drawing and World Space

So now we can start drawing, right? Well, we also have to determine where and
how we want to draw:

![](<screenshots/shooter/tut2.jpg>)

Look at that! This is starting to look impressive! Check out those polygons!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import std
import vec
import color
import gl

fatal(gl.window("Shooter Tutorial", 640, 480))

let worldsize = 20.0

while gl.frame() and gl.button("escape") != 1:
    gl.clear(color_black)
    gl.color(color_white)
    gl.translate(float(gl.window_size()) / 2.0)
    gl.scale(gl.window_size().y / worldsize)
    gl.circle(1.0, 6)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we can actually draw, we have to talk about coordinate systems. By
default, coordinates in Lobster correspond directly to pixels, with (0,0) in the
upper left corner (a left-handed coordinate system), and the total number of
pixels depending on the device (or the user), which during any frame is given by
`gl.window_size`. While working directly with pixel sizes may be useful for some
applications, generally, we want games to be scalable, meaning they should
roughly look the same irrespective of what device they run on.

There is no universal way to do this for games however, because besides
different resolutions, you have the more problematic issue of different aspect
ratios, varying from 4:3 on the iPad (relatively square) to 3:2, 16:10 and 16:9
(longitudinal) on most desktops and other mobile devices. Your game should
ideally look good on that whole range. If you only aim for one ratio, you'll get
borders or things cut off on the other ratios. What works best depends on your
game content.

Here we'll take a simple approach: make the middle of the screen our coordinate
system origin, and rendering outward enough from there that we have all ratios
covered.

gl\_translate changes our coordinate system, and is used throughout graphics
rendering in Lobster to render things at different portions of the screen. Here
we move from upper-left to the middle of the screen by translating by half the
`gl.window_size`.

Then we have to determine how much of the game world we want to show. We don't
want that related to pixels either, as we don't want people with smaller screens
see less of the game. The computer doesn't care about real world sizes like feet
or meters, so we can make up whatever number we want. It is useful however to
pick a number, since that means if we later want to show more or less of the
gameworld, we just have to change one number. Here we say we want the screen to
be able to fit at least 20 units, and we make this relative to the y resolution
of the screen (we're assuming that'll be the smaller one of the two).

Now we can finally draw! Let's put down a temporary graphic for the player.
`gl.circle` draws circles around the current origin, with the first argument
being the radius (see how we're using the world scale for this?), and the second
argument is the number of sides. Setting this to something low like 6 actually
gets us a hexagon rather than a circle.

Pfew, that's a lot of talk just for a circle, but we're getting somewhere. Next
up, let's move our player around. Because games are supposed to be...
*interactive*

### 3: Input, Movement, and Collision

![](<screenshots/shooter/tut3.jpg>)

It moved! I swear!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import std
import vec
import color
import gl

fatal(gl.window("Shooter Tutorial", 640, 480))

let worldsize = 20.0
var playerpos = float2_0
let playerspeed = 10

while gl.frame() and gl.button("escape") != 1:
    gl.clear(color_black)
    gl.color(color_white)

    gl.translate(float(gl.window_size()) / 2.0)
    let scale = gl.window_size().y / worldsize
    gl.scale(scale)

    let dir = float2 { (gl.button("d") >= 1) - (gl.button("a") >= 1),
                     (gl.button("s") >= 1) - (gl.button("w") >= 1) }
    let newpos = playerpos + normalize(dir) * gl.delta_time() * playerspeed
    if not any(abs(newpos) > float(gl.window_size()) / scale / 2.0):
        playerpos = newpos

    gl.translate playerpos:
        gl.circle(1.0, 6)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To make our player move, we added 2 new variables: `playerpos` and
`playerspeed`. We initialize the former with a vector constant from
`vec.lobster`: `float2_0` means all zeroes.

We first figure out which direction the player wants to move by checking the
current state of the WASD keys: by combining the boolean values (0 / 1) for each
direction, both DA and SW give us a -1 / 0 / 1 value which conveniently
corresponds to a directional vector (`dir`).

Now, we can't just add this vector to the player and be done with it, we have to
take into account:

-   If the player tries to move in both x and y directions at once, the
    magnitude of the `dir` vector is sqrt(2) instead of 1, and thus the player
    would move faster! We want him to move in all directions at equal speed.
    `normalize` ensure we have a vector of length 1. You wouldn't believe how
    many games have this bug in it!

-   Remember how the code inside the while loop is our frame? Well, depending on
    the device, we have no idea how many frames per second we're actually
    running at. If we simply move a fixed amount each frame, we'll end up moving
    faster on faster computers! Yet another common bug that we'll avoid by
    multiplying our vector by `gl.delta_time`, which is the number of seconds
    (usually a fraction of a second, e.g. 0.033 at 30 FPS) that has passed since
    the last frame we rendered. The result is that we'll now move 1 unit (the
    length of the vector) per second exactly, regardless of how fast or slow our
    machine is rendering.

-   Of course, "1 unit per second" may well be too slow for our intended game,
    so we factor in our own player speed. We can tweak it later.

-   Last, but not least, once the player can move, we have to worry about him
    staying within the game world. What we have to do, is a very simple form of
    *collision detection*. Collision detection can be very difficult to program,
    but here we start by just checking the boundaries of the screen. Note that I
    put our new position in a separate variable, this is such that we will only
    make it the new player position if we're still inside the world. I also
    created a variable for the scale we set, so that we can use it to know where
    the screen boundaries are. We first take the absolute value of our new
    position (so we only have to check one quadrant of the world). Notice how
    pretty much everything in Lobster works on vectors? This makes it easy to
    write game code without repeating your code for x and y all over the place.
    We compute the size of a quadrant, and compare. `<` here gives us a vector
    of booleans, to check if any coordinates (x or y) were out of bounds, we use
    `any`. If this succeeds, we only then actually move the player. Pfew!

Now we have computed a new position, we have to make sure it has an effect. We
do this by translating our player position from the middle to where we want to
now draw our hexagon. Note something special about this `gl.translate`: it has a
block of code following it (notice the `:`) much like `if` or `for`.
`gl.translate` here actually works like a control structure: it first
translates, then executes the body, then resets the translation. This is because
what we want to render afterwards (enemies perhaps) should not be rendered
relative to the player, but relative to what we had before the player (the world
origin). If that sounds confusing, it may become clearer later with more code.
Stacking all these transformations is one of the more confusing things about
games programming, but it is also rather powerful once you get the hang of it.

### 4: Orientation and Shooting

![](<screenshots/shooter/tut4.jpg>)

What happens as I move the mouse cursor in a clockwise arc around the player
from 12 to 3.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import std
import vec
import color
import gl

fatal(gl.window("Shooter Tutorial", 640, 480))

let worldsize = 20.0

var playerpos = float2_0
let playerspeed = 10

class bullet:
    pos:float2
    dir:float2

let firerate = 0.1
let bulletspeed = 15
var bullets = []
var lastbullet = gl.time()

while gl.frame() and gl.button("escape") != 1:
    gl.clear(color_black)
    gl.color(color_white)

    gl.translate(float(gl.window_size()) / 2.0)
    let scale = gl.window_size().y / worldsize
    gl.scale(scale)

    let dir = float2 { (gl.button("d") >= 1) - (gl.button("a") >= 1),
                     (gl.button("s") >= 1) - (gl.button("w") >= 1) }
    let newpos = playerpos + normalize(dir) * gl.delta_time() * playerspeed
    if not any(abs(newpos) > float(gl.window_size()) / scale / 2.0):
        playerpos = newpos

    let tomouse = normalize(gl.local_mouse_pos(0) - playerpos)

    if lastbullet < gl.time():
        bullets.push(bullet { playerpos, tomouse })
        lastbullet += firerate

    for(bullets) b:
        b.pos += b.dir * gl.delta_time() * bulletspeed
        gl.translate b.pos:
            gl.color color_yellow:
                gl.circle(0.2, 20)

    bullets = filter(bullets) b:
        magnitude(b.pos) < worldsize * 2.0

    gl.translate gl.local_mouse_pos(0):
        gl.line_mode 1:
            gl.color color_grey:
                gl.circle(0.5, 20)

    gl.translate playerpos:
        gl.rotate_z tomouse:
            gl.polygon([ float2 { -0.5, 0.5 }, float2_x, float2 { -0.5, -0.5 } ])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To be able to shoot, first we have to worry about giving our player an
orientation. We compute that in the vector `tomouse` which we get by
subtracting the player position from the mouse position (what we want to shoot
towards). Something funny is going on here though, as the name
`gl.local_mouse_pos` may indicate: normally mouse positions are in pixels, but
those we can't compare against the player position, which is in world
coordinates! `gl.local_mouse_pos` however gives us the mouse position relative to
the current transform, which is world coordinates (as specified by the
`gl.translate` and `gl.scale` above). We then normalize this vector to make it
easier to use, as we don't care about the original length of this vector.

To make the players orientation visual, we first render the player differently:
rather than a simple circle, we render him as a pointy triangle, to make it
clear what direction he's looking at. That's the `gl.polygon` at the end with 3
explicit coordinates (relative to the playerpos, which has now become our
coordinate system origin thanks to `gl.translate`). Additionally, we insert a
`gl.rotate_z` command to make the pointy part of the triangle always look
towards the mouse cursor. The `z` is because if we rotate around the z axis, we
end up rotating the xy plane, which is what we look at in 2D. The argument to
`gl.rotate_z` can either be a vector (as used here) or an angle in degrees.
Vectors are generally awesomer.

Additionally, to cater for situations where the mouse cursor isn't visible
(which it typically isn't in games) we draw a circle (for now) at the mouse
location to give the player feedback where he's aiming at. This starts at the
`gl.translate` before where we draw the player (before, because if the two
overlap, the last one will be drawn on top). We translate to the mouse location
in world space, change the linemode to 1 (which draws just the outline instead
of a filled circle) and change the color. As you can see, all these commands are
ones that undo themselves automatically after the circle is drawn, which is very
convenient.

Now let's start firing bullets. To keep things simple for now, we fire them
automatically, but firing them using a button would be very easy to add (try
it!). We add some constants up top, a firerate (second to fire the next bullet)
and their speed of travel in the world. To keep track of what's going on, we
just need a list of bullets, and track when the last bullet was fired.

We define what a bullet is by defining a new class type, saying that it just
has a current position and direction.

Now look at the `if` inside the code: we check if time has progressed beyond the
point the last bullet was supposed to be fired, and if so, we add a new bullet
to the list of bullets, making it start at the current player position,
travelling in the direction of the mouse. We also increase the `lastbullet`
variable to cause the next one to be fired in 0.1 seconds.

A side note on how we're implementing bullets here: there's a couple of things
not ideal about this, which we do all to keep the example simple and to really
build a game from the ground up. First, the way the checking for time is
implemented here is a bit fragile, as big time fluctuations may cause bullets to
be shot at irregular intervals.

Now that we have a list of bullets being generated, we have to update them and
draw them. The first line in our `for` loop updates them, in a manner that
should look familiar by now: we move the position along the direction, scaled by
the amount of time that has passed this frame and their general speed in world
units per second.

Now they're moving, we can draw them at their current position. We make them
yellow, and 0.2 units in radius.

One last thing to before we're done: our list of bullets will grow indefinitely,
and eventually make the game run to a crawl, even though most have moved off
screen. We'll cull bullets that have moved far enough away from the origin that
they're not visible anymore. We'll do this functional style: `filter` will give
us a new list of bullets for which the magnitude of the position (which is the
same as a vector from the origin, which is the middle of the screen) is within
twice the world size. We could cull them more precisely than this, but for now,
this will have the desired effect of keeping the list small.

Wow, there's a lot to understand to make even a simple game. But the good news
is that in many games you will see the patterns of what we're doing here again
and again, so it is rather useful to get familiar with. It even translates to
3D.

But for now... target practice!

### 5: Enemies

![](<screenshots/shooter/tut5.jpg>)

Since the code is getting long, let's continue, talking purely in terms of
modifications to the existing code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def renderpointytriangle(pos, dir):
    gl.translate pos:
        gl.rotate_z dir:
            gl.polygon([ float2 { -0.5, 0.5 }, float2_x, float2 { -0.5, -0.5 } ])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, let's take the code for rendering the player and put it in its own
function, since we'll be needing it for enemies too. Call instead of the
original code with `renderpointytriangle(playerpos, tomouse)`

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class enemy:
    pos:float2
    hp:int

var enemyrate = 1.0
let enemyspeed = 3
let enemymaxhp = 5
var enemies = []
var lastenemy = gl.time()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can set up enemies analogous to bullets. Of course, we could share some of
this functionality between them, but let's not complicate matters for now. Add
this to the declarations.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if lastenemy < gl.time():
        enemies.push(enemy { sincos(rnd(360)) * worldsize * 2.0, enemymaxhp })
        lastenemy += enemyrate
        enemyrate *= 0.999

    for(enemies) e:
        let playerdir = normalize(playerpos - e.pos)
        e.pos += playerdir * gl.delta_time() * enemyspeed
        for(bullets) b:
            if magnitude(b.pos - e.pos) < 1.0:
                e.hp = max(e.hp - 1, 0)
                b.pos = float2_x * worldsize * 10.0
        gl.color lerp(color_red, color_blue, div(e.hp, enemymaxhp)):
            renderpointytriangle(e.pos, playerdir)

    enemies = filter enemies: _.hp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

During the frame, we use the above code to deal with enemies, which is very
similar to bullets yet again. We spawn new enemies initially once per second. To
compute a spawn location, take a random angle, convert to a vector, then offset
that vector to somewhere outside the screen to have them flock in from all
directions.

We do one special thing: we keep reducing the enemy rate subtly. This guarantees
the game will get harder and harder and the player will guaranteed die
eventually, it is just a matter of when.

Then we loop through all enemies, compute a vector towards the player, and move
the enemy towards him. Of course, now we need to do collision detection between
bullets and enemies, which we do in brute force manner by checking every bullet
with every enemy. If the quantity of both stays low, this is ok, but for large
amounts of objects this approach will eventually get too slow, requiring
bucketing of objects in a grid. For now, this is ok. We check the distance
between the center of the bullet and the center of the enemy, and consider it a
hit if they are a generous 1 unit apart or less. Of course, we could check exact
collision with the triangle, but besides being complicated, it might not even be
desirable for gameplay.

If we have a hit, we reduce the HP of the enemy by one (we're using `max` to
ensure it doesn't go below 0, you'll see why in a bit). We also need to "kill"
the bullet when that happens, but since we already have code that removes
bullets that leave the world, we are lazy and make use of that, by moving the
bullet far from the center.

Then we render the enemy conveniently with our existing function. We do
something fun here, letting the health of the enemy determine its color, from
healthy blue to a dead red. We use `lerp` (linearly interpolate) of 2 colors.
`div` is a useful function that does the same as `/` on 2 integers but gives a
float result.

Then of course we need to cull dead enemies, which we do with a similar `filter`
function. Culling all at once like we do here with bullets and enemies is nice,
because culling during update can introduce subtle bugs.

We can't really play yet however, since we can't die...

### 6: Score, and Game Over

![](<screenshots/shooter/tut6.jpg>)

Now we have some loose ends to wrap up to call this thing a "game": we have to
keep track of the player health and score (and highscore), and give him a start
/ game over screen in-between sessions.

To do that, we will have to be able to render text. First step towards doing
that is loading up a font, right after `gl.window`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check(gl.set_font_name("data/fonts/US101/US101.ttf") and gl.set_font_size(32), "can\'t load font!")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`check` is another useful function much like fatal, that ensures the first
argument is true, and if not, exits the program with the given message.

To implement the functionality, we start with some new variables:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var playerhealth = 0.0
var score = 0
var highscore = 0
var playing = false
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

inside our frame, we then test our `playing` variable, and when true, run the
game code we were running before, and if false, display the in-between screen,
which simply says:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        let msg = "press space to play!"
        gl.translate (gl.window_size() - gl.text_size(msg)) / 2:
            gl.text(msg)
        if gl.button("space") == 1:
            score = 0
            playerhealth = 100.0
            playerpos = float2_0
            bullets = []
            lastbullet = gl.time()
            enemyrate = 1.0
            enemies = []
            lastenemy = gl.time()
            playing = true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `gl.translate` centers our text using the handy `gl.text_size` which tell us
the size of a string in pixels before we've even rendered it. `gl.text` then
draws it. We then reset the game state when the game starts, and next frame the
game will be playing.

To show the current state to the player, we use the simple:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    gl.text("health: {ceiling(playerhealth)} - score: {score} - highscore: {highscore}")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We call this as the very last thing in the frame, so it is visible regardless of
whether the player is in-game or not, for simplicity. `ceiling` is useful since
we'll be calculating the player's health in float, but want to show only the
whole numbers. `ceiling` here is better than `truncate`, since we only want to
show `0` when the player is truely dead.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                let playervec = playerpos - e.pos
                if magnitude(playervec) < 1.0:
                    playerhealth -= gl.delta_time() * 50.0
                    if playerhealth <= 0.0:
                        playerhealth = 0.0
                        highscore = max(highscore, score)
                        playing = false
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Then finally, inside our `for(enemies) e:` loop, we add this bit of code which
checks if this particular enemy is "touching" the player. If so, we subtract
health for how long he is touching. If the player runs out of health, we update
the high score, and revert back into non-playing mode.

Game Over, and Tutorial Over!

### 7: What's next?

We now have a very basic structure of a game. While it is not impressive, it
does deal with all the typical things a game does, and thus extending it from
here should be fun and easy. Some ideas of things you could add:

-   Tweak all the current variables: player and enemy speed, enemy health and
    spawn rates, etc. The current ones are workable defaults, but are they the
    most fun?

-   A variety of enemy types. You can make them differ by speed, size and
    hitpoints easily, though giving them different behaviors will give even more
    variety.

-   Pickups for the player. Think of randomly spawning health boxes, and
    powerups (faster fire, spread fire etc).

-   Better graphics! It is a very good idea to make a game fun first with
    geometric shapes like we have done, but then once the game has taken shape,
    adding graphics can make the game feel more immersive and give better
    feedback to the player.

-   Better UI and main menu.

-   Game structure: different levels the player can try to beat, permanent
    upgrades the player can buy, etc.

Also, at this point, our game has no sound at all. If you'd like to see how to
add some ambient or enemy sounds, have a look at the use of the `play_` and
`sound_` functions in `tut_sound.lobster`. This example also shows how to to
dynamically adjust the volume and pause or resume individual sounds.

This tutorial has all game state in top level variables, for simplicity of
explanation. If you want to have a look at what the code would be like if you
instead stored all of it in classes, have a look at `tut_obj.lobster`.

</contents>
<source>
/tmp/tmpo9l8mwkb/style_guide.md
</source>
<contents>
---
title: Lobster Style Guide
---

This document defines the style that ideally should be used for all lobster
programs.

Why this document?
------------------

There is no such thing as the provably best style for writing code: it all comes
down to human preference. But one thing is extremely detrimental to reading
code: inconsistent source code formatting. Hence why it is good to have a fixed
style.

You are free to pick any style the compiler will accept for your own projects,
of course. But if you wish to cooperate with other Lobster programmers, using
the style set forth in this document will be helpful. Most code you will find
will use this style, so trying to enforce another style may be tricky.

Python, being the language closest in syntax to Lobster, has a well defined
[style guide](<http://www.python.org/dev/peps/pep-0008/>), and so do other
languages, like Java. C/C++ in particular has failed to establish a clear style,
which is a constant source of confusion and disagreement.

Default Style
-------------

Unless noted explicitly in this document, the style to follow is that of the
samples in the Lobster documentation and distribution. Let's look at a typical
example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def qsort(xs, lt):
    if xs.length <= 1:
        xs
    else:
        let pivot = xs[0]
        let tail = xs.slice(1, -1)
        append(append(qsort(tail.filter():     lt(_, pivot), lt), [ pivot ]),
                      qsort(tail.filter(): not lt(_, pivot), lt))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Indentation: Tabs vs Spaces

By default, you should use 4 spaces to indent (same as Python). The compiler
will allow you to use tabs (discouraged), and in some cases even a mix (highly
discouraged).

The compiler will error on mixed use of tabs and spaces, as that could change
what code appears to mean.

In theory, tabs are superior for editing, but in practice, different editors and
different methods of displaying code can make tab based code work
inconsistently, which is more of a problem for a language with significant
indentation like Lobster and Python.

### Whitespace

Typical use of whitespace is around any binary operator (in the example `<=`
`=`), after a `,` and inside `[]` when used as vector constructor or definition
(but not when used for indexing, and not inside `()`).

### Alignment

As seen in the `append` call, you are encouraged to make similar code line up
using extra spaces. Because the first part of the `append` call ended in a `,`
the second line is not counted as an indentation in the same way as the
indentation blocks above it.

### Identifiers

Lobster uses lowercase for almost all identifiers. If an identifier consists of
multiple words, they are preferably just written consecutively, though for cases
where that becomes unreadable using an `_` to separate them is ok. Do not uses
`_` to start or end regular identifiers (see the reference manual about
anonymously declared variables).

### Indentation vs one-liners

Prefer indentation over one liners unless the block is very short, e.g. `if a <
0: 10 else: a - 5` is better in-line than indented. Avoid the use of `;`
generally, if you need multiple expressions in a block, indentation is superior.

### Prefer the shortest form

Whenever short forms are available for a particular syntax, prefer to use that,
unless readability would suffer.
</contents>
<source>
/tmp/tmpo9l8mwkb/sublime_ide.md
</source>
<contents>
---
title: SublimeText as Lobster IDE
---

## Running Lobster programs from within the editor

-   This assumes SublimeText 3, though may also work with older
    versions.

-   Copy the files in the `docs/sublime` folder to your
    `Packages/User` folder (on Windows this is
    `\Users\YourUserName\AppData\Roaming\Sublime Text 3\Packages\User`).

-   Open up `lobster.sublime-build` and make sure the path to your
    lobster executable is correct. Also note that it refers to a custom
    version of `exec.py` called `lobster_exec.py`. The only difference
    is that the default script suppresses windows from popping up, which
    disables any graphical output from Lobster.

-   Load some lobster code. pressing `ctrl+b` should run it.

## Editing

By default, SublimeText comes set up insert tabs into your code, which
is against the Lobster [style guide][], and can result in errors if you
modify the existing examples. Add `"translate_tabs_to_spaces": true` to
your user settings.

## Error Highlighting

The build script parses Lobster error messages, so just pressing F4 will
get you to the line of the error.

## Syntax Highlighting

The `lobster.tmLanguage` file you copied should provide automatic syntax
highlighting for any .lobster files.

##

  [style guide]: style_guide.html
</contents>
<source>
/tmp/tmpo9l8mwkb/type_checker.md
</source>
<contents>
---
title: The Lobster Type System
---

This document is about how to make most effective use of the type system..

The nature of the type system
-----------------------------

Lobster was originally dynamically typed. Not only is this easier to implement,
it bring tremendous expressive power "for free", particularly in the way it
allows you to write generic code which often requires arcane typing annotations
in static languages. The downsides are obvious too: type errors come late or
stay hidden, and execution speed suffers.

The type system in Lobster attempts to achieve the best of both worlds, with a
type system that retains as much as possible of the dynamic style of writing
(little to no type annotations needed, while able to type check a much broader
range of code than other languages). It achieves this by using 3 techniques that
build on each other:

1.  **Type Inference**. A well known technique by now, as many language employ
    it one way or another, and it is an obvious way to reduce type annotations.
    By itself it is rather restrictive however, as it is limited in the kind of
    generic code it can correctly type.

2.  **Specialization**. Instead of struggling to infer or define generic types
    for everything, we specialize functions to the exact parameter types they
    are called with. This allows a much wider range of possible code inside
    generic functions, since they are only ever type-checked with specific
    types. This of course requires there to be multiple copies of functions, but
    in practice the code expansion is minimal. Specialized code can be optimized
    and inlined more aggressively, resulting in significant speed advantages
    besides the expressivity gains.

3.  **Flow Based**: Type checking happens in order of function calls, i.e. it is
    much like evaluating the code, but with types instead of values. This means
    that when type checking a particular function, it not just knows the exact
    types of parameters (thanks to specialization), but also the types of free
    variables, and it knows its callers (a compile time call stack). This means
    that when a type error happens, you can see in what context the wrong type
    got created and passed down. Think of it as an earlier dynamic type error.
    In addition, it takes into account the state of conditional statements,
    allowing you to avoid unnecessary type errors.

As a result, you are less constrained in the kind kind of code you can write
that still type checks correctly, while using less annotations. But with great
power comes great responsibility: the less annotations you write, the more a
compile time error indeed looks like a run-time error: they are almost as hard
to track down. It is certainly easy to start with no annotations, and then
gradually add them in places to force type errors to come earlier and be easier
to understand. Find your own trade-off.

Writing generic code
--------------------

In the simplest cases, there is no difference between writing dynamically typed
code and typed code. For example a simple function like:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def add(x, y): x + y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

is how you create a generic functions in either case. You create a generic
parameter by.. not specifying a type!

Now this is already a non-trivial example that will trip up many languages with
type inference, since you cannot have the arguments be generic unless the `+`
operation is defined on them, requiring them to have a way to specify the set of
types that have this operation specified (see e.g. type classes in Haskell), or
simply not allowing it at all (see e.g. generics in Java).

Lobster does not have this problem, since it simply type checks a copy of `add`
for each combination of types it is called with. This then deals correctly with
allowing to write `add("number: ", 4)`, taking care of converting `4` to a
string and calling string concatenation on the result, without making simpler
cases like `add(1, 2)` slower because of type inspection. In fact, the
opportunities for statically optimizing these operations are now greatly
increased. This is very similar to C++ templates, but without the clunky syntax.

It is typically "good style" in Lobster to use untyped arguments when a)
multiple types are possible/useful, and b) there is no relation between the
types of the arguments. Sometimes it is useful to use explicit generic
annotations, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def add<T>(x:T, y:T): x + y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Would enforce that both parameters are of the same type, unlike the example above.
The type `T` is automatically deduced from the first argument that matches it (in
this case, the first), and then any further uses are required to be that same type,
so for example `add(1.0, 1)` would make `T` a `float`, and thus coerce the second
argument to `float` before the function call. In the untyped case above, it would
specialize `add` for `(float, int)` arguments, and the coercion to `float`
(required by `+`) would now happen inside the function.

You can even specify the generic type explicitly, for example `add<float>(1, 1)`
would actually coerce both arguments ahead of time. If the function has
multiple generic arguments, you don't need to specify all of them, if the
remaining ones can be inferred. Caveat: this currently only works where the `<`
directly follows a known function name (to distinguish it from uses of the
`<` operator).

And all of this also works on untyped function declarations equally, since they
internally get converted to explicit generics by simply adding generic types
`A, B, C,..` to them for their untypes arguments.

You can use generic types from surrounding functions, and from any class
this function is a "method" of (either declared inside that class, or with the
class type as first argument).

The trouble with nil
--------------------

So far, the type system tries to preserve as much freedom of dynamic typing as
possible. One area where it is however *more* strict than most existing
languages is how it deals with `nil`.

`nil` (or `null` in other languages) is usually a default value of all reference
types, which is very convenient in expressing uninitialized or optional values.
But this convenience comes at a high cost: if you forget to check for `nil`
before you access a value, your program may terminate with a run-time error.
Very often we know a value cannot be `nil`, but we cannot guarantee this, or are
lazy to do so. Result: random errors popping up in random places. Not good.

Lobster takes the obvious approach: `nil` is a separate type that is *not a
valid value* of a reference type. You may still create "nilable" types, but
these cannot be accessed (e.g. dereferenced) unless they are first converted to
their underlying type:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var a = nil      // a is a nilable of unknown type
if ..:
    a = "foo" // a is a nilable string
a += "bar"    // error: + not defined for nil
if a:         // guaranteed not be nil inside block
    a += "!"  // ok: a is of type string here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As you can see, we can use conditionals to guard code that wants to access a
nilable. This seems like a hassle maybe, but think of the benefit: you will
never see a `nil` related run-time error *ever again*.

And now that `nil` is a separate type, we can improve our code by not using
`nil` unless absolutely necessary. Many uses of `nil` in legacy code are lazy,
and can be avoided:

-   If at all possible, try to reorder code such that variables can be
    initialized to a valid value right where they are defined. This is often
    possible.

-   If the variable cannot be initialized where it must be defined, see if
    there's a "empty" version of the reference type that the variable can be
    initialized with, such as an empty vector or string, or a class filled with
    zeroes, that has a benign effect when used.

-   If you must start with `nil`, try to have the if-check for it as early on as
    possible, so all code deeper down the call chain can benefit from a non-nil
    type that doesn't need to be checked.

The flow based analysis generally understand logical expressions, so if you
write `if not a:` instead, you'll be able to access `a` in the `else` block, but
not in the `then` block. Similarly, if you write `if a and f(a):` then `a` is
available as non-nil both as argument to `f` *and* in the following block.

`?` is generally the way to indicate a nilable type, e.g. `string?` is a nilable
string.

One more thing to notice about `nil` is that it only knows what exact nilable
type it represents once it comes "in contact with" its reference type. That
means that if you tried to access `a` right after it was defined, it would have
still have type `nil` rather than `string?`. Similarly, if you tried to assign a
vector to `a` after the first assignment, it would complain that only a
`string?` is valid, i.e. a `string` or `nil` value.

To bypass that process and force `nil` to represent a particular nilable type,
you can attach a type, like `nil:string`, which creates a value of type
`string?`. Alternatively you could write `nil and a`, which makes `nil` have the
type of whatever `a` has, which may be a generic variable. Similarly, `a or nil`
has the same nilable type, but now the value is actually `a` rather than `nil`.

More flow based types
---------------------

As we saw with `nil`, a variable may have a different type in certain parts of
the code, thanks to the information that a conditional provides.

Another example of this is the `is` operator:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if a is xyz: a.x
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can access fields of `xyz` regardless of what type `a` had outside this
scope. `is` is only true if the types are exactly equal, not subtypes.

Assignment can work similar to conditionals:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var a = nil
if ..: a = float3_0
a.x        // error
a = float3_0  // a is guaranteed non-nil below
a.x        // ok
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note how there are two different cases here: with an assignment inside a
conditional, the type checker has to be conservative, and can't guarantee the
value is non-nil. But with an un-conditional assignment, we can change the type
of `a` for the rest of the block.

An additional way is to use `assert`. Use this when you know for sure a value
must be non-nil or have a particular type, but you can't structure your code
such that this is already obvious to the type system.

Compile-time if-then's.
-----------------------

The flow-based type-checking above gives branches more specific types. But we
can do even better: if the condition is statically known, we can avoid
type-checking altogether:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def compile_time_if(x):
    if x is int or x is float:
        1 / x
    else:
        x
assert(compile_time_if(1) is int)
assert(compile_time_if("") is string)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The division would be a type error if x is a string, but it compiles anyway
since this if is compile-time constant, and the type checker ignores this
branch.

If you're used to dynamic languages, you might think: what's the fuss? This
would be a compile error in almost all statically typed languages, since they
don't cull code before the optimizer. For example with C++ templates can't
handle this situation, and that's already more powerful than most forms of
generics.

Also note the return type is just the else branch in the string case, it doesn't
need to make a type union between the branches anymore.

This is powerful, because it allows you to write generic functions that do
subtly different things depending on the input, with no overhead from the
conditional, and the ability to operate differently on each case.

You can do something similar with overloading / dynamic dispatch, but that may
require more code or may be less efficient.

Generic classes and structs
--------------------------

Besides functions, classes can also be generic, but here we only use explicit
generic parameters to do so:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class foo<T>:
    a:string
    b:T
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can now create named specializations using this syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class foo_f = foo<float>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can now construct a foo with floats, either explicitly with `foo_f { "hi",
2.0 }`, or you can use the generic type: `foo { "hi", 2.0 }` and let the
compiler pick from all available named specializations. If you wish, you can
also construct a specialization directly without naming it: `foo<float> { "hi", 2.0 }`

Functions written to accept `foo` arguments will of course work on any of the
specializations.

You can even specialize and subclass at the same time:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class bar : foo<float>
    c:int

class bar<T, U> : foo<T>
    c:U
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first specializes and subclasses at the same time, creating a non-generic type.
the second version subclasses `foo` into another generic type, passing on one generic
parameter and introducing another.


Numeric Structs (math vector types)
-----------------------------------
Structs whose fields are either all int or all float have a special status in
the type system, as they are accepted as arguments to vector versions of the
built-in operators (`+ - * /` etc) as well as many vector operations part of
the built-in functions (e.g. `normalize`).

You can see the default types for these (`vec2`, `vec3`, and `vec4`) defined in
`modules/stdtype.lobster`. Other types also work with these operations, though
(e.g. `color`).

Confusingly, in math, such N dimensional things are commonly referred to as
"vectors", whereas Lobster calls its resizable arrays "vectors". So in Lobster
these things are "numeric structs", but on occasion may still also be called
"vectors", sorry for the confusion.
</contents>
<source>
/tmp/tmpo9l8mwkb/vscode_ide.md
</source>
<contents>
---
title: VSCode as Lobster IDE
---

VSCode extension
-------------------
The vscode extension includes syntax highlighting, 
a lobster LSP (Language Server Protocol).

See [here](lsp.html) for more info about the lobster LSP.

### How to install
-  Get the file `lobster.vsix` found in the repo at `docs/vscode/lobster.vsix`.

-  Open your vscode command palette and search for `Install from VSIX`. Then select the file mentioned above.


Running Lobster programs from within the editor without the extension
-----------------------------------------------

-   Copy `docs/vscode/tasks.json` to a `.vscode` workspace folder that
    is in the root of where you keep your lobster code.

-   Load some lobster code. pressing `ctrl+shift+b` should run it. If there was
    an error, press `F8` to go to it, and/or `` ctrl+` `` (shell) to show
    program output.
</contents>
</root>
